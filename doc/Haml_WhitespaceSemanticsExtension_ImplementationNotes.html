<h1>Haml Whitespace Semantics Extension (WSE) Implementation Notes</h1>

<p>Draft v0.2, 12 Sept 2010</p>

<h2>Authors</h2>

<p>Proposer: Nick Ragouzis, Enosis Group</p>

<p>Contributors:</p>

<h2>RSpec and Test::More</h2>

<p>A suite of specifications and tests accompany this text.</p>

<p>The file <strong>00ImplementationNotes</strong> contains the snippets found in this
text, pretty much as shown ... well, that was the plan.</p>

<p>The files numbered from <strong>01</strong> to <strong>14</strong> are by topic, contain specifications
and demonstrations of WSE Haml extensions, and a few of the bugs in
legacy Haml. We <em>highly</em> recommend a detailed review of those files,
as not all aspects of the proposed WSE extensions are documented in 
this text, and not all bugs encountered in legacy Haml (Ruby, or
Perl ... and the bugs do differ) are documented in this text.</p>

<h2>Shiny Things</h2>

<pre><code>  
  Code 3-01

  Haml                              Html
  ---------------------             -------------------------
  %gee                              &lt;gee&gt;
    %whiz                             &lt;whiz&gt;
      Wow this is cool!                 Wow this is cool!
                                      &lt;/whiz&gt;
                                    &lt;/gee&gt;
</code></pre>

<p>The above is from the HAML_REFERENCE[1], which introduces Haml
(<em>XHTML Abstraction Markup Language</em>) as </p>

<pre><code>  ... a markup language that's used to cleanly and simply 
      describe the XHTML of any web document...
</code></pre>

<p>And breezy cool it is.</p>

<p>And yet ... there is a sense that Haml is a bit tetchy. </p>

<p>Although Chris Eppstein, in 2010, makes the distinction between content versus 
layout[2], the challenges he cites do not hew to that distinction; they have a
more fundamental emanation. Those challenges share a common thread with many 
forum questions (Google and SO) about Haml. These also share a common thread 
with the problems Nathan Weizenbaum worked through in 2008[3]. </p>

<p>That common thread: the ancient concern of author control.</p>

<p>This rises to ironic levels with Haml. Haml is not just (another) macro
processor with embedded language capabilities; from a clean and simple
description of XHTML, it promises well-formatted XHTML output. In other 
words, it dresses up for just the geeks who are drawn to author control, 
and then leaves them a bit disappointed.</p>

<p>The extensions proposed in this document (and illustrated in the accompanying
RSpec suite), Whitespace Semantics Extensions, or WSE, attempt to address one
large and pervasive component of those problems: whitespace, its specification
by authors, processing by Haml to recognize author intent, and it appearance 
or absence in Haml output.</p>

<p>Although some will see this proposal as <em>quite enough,thank you</em>, a reviewer
or implementer, or author, will likely see other candidates for improvement.
It is our hope this proposal will kick off further discussion, corrections,
and improvements by the community.</p>

<ul>
<li><p>[1] <a href="http://ham-lang.com/docs.yardoc/file.HAML_REFERENCE">HAML REFERENCE</a></p></li>
<li><p>[2] <a href="http://chriseppstein.github.com/blog/2010/02/08/haml-sucks-for-content/">Chris Eppstein</a></p></li>
<li><p>[3] <a href="http://nex-3.com/posts/75-haml-whitespace-handling-sucks-too">Nathan Weizenbaum</a></p></li>
</ul>

<h2>Motivation</h2>

<p>About a year ago, circa September 2009, Nathan Weizenbaum (nex3, the 
maintainer of the Ruby implementation of Haml) filed Issue #28, entitled 
<em>Allow variable indentation under certain circumstances</em>. 
Visit: <a href="http://github.com/nex3/haml/issues#issue/28">GitHub nex3 Haml Issue 28</a>.</p>

<p>Nex3 says:</p>

<pre><code>  Label: Hard

  We want to allow variable indentation as long as it's unambiguous. 
  For example, the following:

  Code 4-01

  %foo
    %bar
        %baz
          bang
        boom

  should be [rendered in HtmlOutput] the same as:

  Code 4-02

  %foo
    %bar
      %baz
        bang
      boom
</code></pre>

<p>Nex3 continues:</p>

<pre><code>  However, wherever we currently would raise an error, a 
  warning should be printed.

  Ambiguous cases should still be marked as erroneous. 
  For Example, the following

  Code 4-03

  %foo
      up four spaces
    down two spaces

  should raise an error on the "down two spaces" line.
</code></pre>

<p>As preview, here is one WSE Haml interpretation. For alternatives,
see the referenced code spec, and other rspec suites mentioned there:</p>

<pre><code>
  Code 4-04

  %foo
      up four spaces
    down two spaces

  &lt;foo&gt;
    up four spaces
    down two spaces
  &lt;/foo&gt;
</code></pre>

<p>The extensions to whitespace semantics proposed in this document attempt
to spell out the implementation of such a change, and its ramifications.</p>

<p>Well, a bit more than that ... because on initially reading Issue 28, 
it seemed it is probably unnecessary and unhelpful to raise warnings, and 
it is probably possible to disambiguate the case above which nex3 labels 
as ambiguous, and many others as well.</p>

<p>Yes, that's all it took, and after a bit of study and testing, here you go.
And, yes, if only because there were a few other teensy irregularities to
sort out: hard.</p>

<h2>Background, or The Case For Change</h2>

<p>We think we can improve things a little for Haml authors.</p>

<p>This document accompanies a Perl implementation of proposed extended 
whitespace semantics for Haml. We propose and demonstrate several ideas, 
some extensions of which address issues already seen, while other 
extensions are part of improving some aspect related to the whitespace 
semantics. </p>

<p>The focus is, most specifically, on the block structure and  whitespace 
characteristics of Haml source, and of the resulting HTML.</p>

<p>As a language, Haml grants significant semantic power to whitespace.
Yet, the semantics and implementation remain somewhat rough, as is
revealed with a brief experience with Haml, or a quick run of just
a bit more complicated test cases, or a perusal of the issues filed
on GitHub including ideas logged by the current maintainer 
<em>nex3, Nathan Weizenbaum</em>.</p>

<p>We treat Haml as a domain-specific language for describing HTML, and XML 
(including XHTML) files. (We say "Html" except where differences are 
significant and non-obvious; in this we depart from the Haml specification, 
for reasons that we hope will become obvious.) </p>

<p>Coarsely, Haml offers: a tag macro language, a templating and variable 
substitution language, and access to underlying programming language 
facilities. </p>

<p>In form, Haml is marked most by two characteristics:</p>

<ol>
<li><p>By representation of HTML elements through use of start macros, and</p></li>
<li><p>By use of indentation to demarcate the extent of model content.</p></li>
</ol>

<p>In Haml's history most of the conversations around author expectations
of whitespace and input or output formats have been resolved by finding 
some other way to get the desired results, or sometimes by language 
extensions or fixes. Some entirely reasonable author inquiry about their 
(entirely reasonable) expectations regarding whitespace and Haml's ease 
of use has been met with "don't do it that way", and others by 
"that's unimportant, not what Haml's about".</p>

<p>These latter responses are unsatisfactory, especially since, well,
whitespace is important to folks for whom whitespace is important.</p>

<p>Consider for a moment: As with Html, Haml is used to describe the hull, 
framework, and substructure of a webpage (by means of the Html it yields). 
Both can be said to carry the design of the page, but neither embody a 
design language (just as it would be clumsy to call "I" beams and rivets 
the design language of a bridge). Haml, rather, strikes a tradeoff: for some
of the advantages in writing in or designing to 'pure' Html, Haml defines 
an attractive engineering shorthand. The syntax and surface structures of 
Haml, and the resulting Html, are tuned to deliver related benefits in 
simplicity and clarity. </p>

<p>So, authors who adopt Haml directly are essentially similar to those using
Html directly, yet they seek the core benefits of Haml: abbreviated 
descriptions and relief from nuisance syntax. They also seek, or appreciate,
improved legibility. For this they will accept certain tradeoffs and 
limitations.</p>

<p>For one author of this document (Ragouzis), it seemed a particularly 
bothersome breakage of DRY when Haml mercilessly condemn to that 
brain-dead drum circle of hedge-trimming (re-indenting) text. </p>

<p>It seems a particularly bothersome breakage of DRY, however, when Haml 
mercilessly condemn the author to that brain-dead drum circle of 
hedge-trimming (re-indenting) text. </p>

<p>Who is to say authors must forfeit benefits or practices that Html itself
made possible? Despite all its detractions, Html's essential characteristic
is that humans can parse it, and through text surface structure, whitespace,
and grouping (which are distinguished less by stricture than by a loose, 
even expressive, flexibility), authors could achieve improved scanning, 
legibility, comprehension, and maintainability of the Html. (Even Adobe 
Dreamweaver gives a nod to this effect, with options for block and 
whitespace structures in the resulting code.)</p>

<p>Granted, at production, and certainly at browser rendering, all of these 
benefits are much less salient. But Haml, and the need for working through 
Html, is more a part of the earlier part of the process: the beginning, and 
the vast and distributed middle. As a result, questions about, and control of
whitespace in the resulting Html is a legitimate consideration for Haml 
design, implementation, and relevant to its acceptance.</p>

<p>In short: Whitespace and block structure matters in input, and output; the 
most credible claims to the contrary are those offering significant,
demonstrable, improvements to legibility or brevity. </p>

<h2>Haml Whitespace Processing, Overview</h2>

<p>In Haml, whitespace is 'active.' Parsing Haml can be viewed, largely, as the
lexical decoding of whitespace, and assigning semantics to whitespace-related
productions and proximate text.</p>

<p>The whitespace of a HamlSource, or (Haml) template, determines both 
HamlSource processing, and the appearance of the HtmlOutput. To that is 
added the semantics of the non-whitespace tokens, which include text to be 
transformed, text to be copied through, evaluation forms, and a few 
processing instructions. For the most part, this document pushes transforms
and processing to the background: the focus is whitespace.</p>

<p>Notice that this document concerns Haml itself, not the related
mechanisms. We will be working with the HamlSource, and the HtmlOutput.</p>

<p>In the Haml literature, sometimes the HamlSource is referred to as a
template, or a partial; sometimes it is the output that is called a 
template. It is true that in actual applications the input may be 
substantially a document of interpolation and computation, or that the 
output may be substantially a document prepared for further interpolation 
and computation. Regardless, here we do not work with templates of any 
kind: a HamlSource is prepared by an author, processed by the Haml processor,
producing an HtmlOutput.</p>

<p>For this document and implementation, here's the setup:</p>

<pre><code>               HamlSource 
                   |
                   v
  Haml Processing: Interpreter &amp; Generator
                   |
                   v
  (black box: interpolation &amp; computation) 
                   |
                   v
               HtmlOutput
</code></pre>

<p>The Haml syntax is (mostly) inert wrt template-like processing: e.g.,
erb &lt;%...%> means nothing in HamlSource syntax. So, although the 
following are possible processing models, these extensions do not
look to their requirements:</p>

<pre><code>  HamlSource --&gt; TemplateOutput (with templating constructs)

  HamlSource --&gt; ERB (Ruby-Html) template --&gt; ('pure')HtmlOutput

  SassSource --&gt; (Haml-like syntactic analysis) --&gt; CSS 
</code></pre>

<p>In other words, with the focus on HamlSource, and its resulting HtmlOutput 
(no matter how embellished) the extensions to whitespace semantics (WSE) 
discussed here do not consider templates or intermediate forms and
processing. If you are concerned with these other areas, you might be able
to expand on these extensions or their support -- that would be great.</p>

<p>A HamlSource begins in the first column of the first line (denoted
indent 0 of line 0). A Haml document tree is built up from there,
through a series of Elements, in succession. Mostly, the tree is built
up in depth-first, 'preorder', fashion, where each parent directly
contains and completely describes all of its children, although some
variance from this is provided by variable assignment and substitution,
evaluation forms, and processing instructions.  </p>

<p>We propose three frames for whitespace semantics:</p>

<ol>
<li><p>HamlSource lexical and syntax scanning and analysis</p>

<p>This frame concerns understanding and codification of author intent
through inclusion or omission of whitespace. The obvious case is the
indent-sensitive grouping of content. Less obvious: the mixing of 
content models or the relationships of sequential blocks.</p></li>
<li><p>HtmlOutput code format</p>

<p>Whitespace in HamlSource also signals an author's intent for formatting of
HtmlOutput. Indenting of output is a simple case. More complicated is the 
treatment of trailing or internal whitespace, or preformatted or 
interpolated texts.</p></li>
<li><p>HtmlOutput code content</p>

<p>This frame of whitespace semantics concerns the content of the view, plus 
any necessary view-related concessions. Some generated forms must concern 
themselves with the content itself, and even how Html UA (and similar) are 
likely to interpret the content. Think Html &lt;pre&gt; and friends.</p></li>
</ol>

<p>The proposed extensions touch on all three frames, including that second
frame where, thus far in Haml development, the extent of attention has 
been what has been called <em>tabbing</em> (output indentation). The extensions
proposed here suggest improvements in these whitespace semantics utilizing 
available degrees of expression in the HamlSource.</p>

<h2>The Haml Whitespace Semantics Extensions (WSE), In Brief</h2>

<p>Main points:</p>

<ul>
<li><p>Mixed Content </p>

<p>A mixture of Inline Content (on the Head) and Nested Content</p></li>
<li><p>Plaintext Nesting </p>

<p>Nesting is now permitted in Plaintext for most operators</p></li>
<li><p>Preformatted </p>

<p>An extension of <code>option:preserve</code>, with Mixed Content, without newline 
transforms. Includes a partner <code>filter:preformatted</code>. In WSE Haml, 
by default, <code>%pre</code> and <code>%textarea</code> shift from <code>option:preserve</code> 
to <code>option:preformatted</code>. Authors will add to <code>option:preformatted</code> any
tags for which they assign CSS <code>white-space:pre</code>-like mechanics.</p></li>
<li><p>Vertical Whitespace </p>

<p>Vertical whitespace will now separate Html hunks (changed handling of whitelines)</p></li>
<li><p>Multiline Processing </p>

<p>Improvements to the syntax for adjacent Multiline blocks, to Haml Comment 
processing, and introduction of Whiteline termination.</p></li>
<li><p>HereDoc</p>

<p>Introduction of HereDoc &lt;&lt; to supply a ContentBlock</p></li>
<li><p>Haml Comment Markup </p>

<p>Improved rules for Haml markup comments</p></li>
<li><p>OIR:strict </p>

<p>Set the Orderly Indentation Rule similar to legacy, with more flexibility 
for IndentStep Indents and Undents, removing many aspects of the tedious 
indent tidying during content and layout maintenance.</p></li>
<li><p>OIR:loose </p>

<p>The default in WSE, simplifying the blocking rules immensely, without 
ambiguity. Entirely removes tidying tedium where, after maintenance of 
content or layout, content remains a descendant of the preceding elements. 
Copy-paste maintenance is also simplified.</p></li>
<li><p>Escaped HtmlOutput </p>

<p>When an author requests HtmlOutput with parts of it transformed to 
prevent its later interpreted as part of Html document syntax, WSE Haml 
now implements an idempotent, fixed point, model: 
<code>&amp;amp;</code> never becomes <code>&amp;amp;amp;</code>. </p>

<p>Further, the transformation to character entity references is conditioned 
on doctype and Haml options. </p>

<p>Regarding the motivations for this change. One motivation concerns the 
semantics of document processing: In Html, an escaped text is one which 
each symbol intended as [plain] text is of an encoding which assures it 
will transit document processing and be rendered as [plain] text. More 
particularly, that all symbols having significance to Html document syntax 
processing be represented (here, encoded) in such a way as to <em>escape</em> 
such syntax processing. Thus, <strong>in Html</strong>, considering two separate 
encodings of the ampersand, <em>&#x0026;</em> is a symbol susceptible to Html syntax 
processing, which would require a different encoding when a part of 
[plain] text; <em>&amp;amp;</em> is not, and does not. </p>

<p>As a more Haml-focused motivation, WSE Haml in general manifests a change
of focus from a mostly processing- and programmer-focused view, to that
of an author-focused HamlSource and HtmlOutput view. Thus WSE Haml 
changes 'escaping' transforms from that of 'sanitizing' or 'find-replace', 
programmer-focused mechanics, to that of the HtmlOutput, author-focused 
results.</p>

<p>The escaping changes apply across <em>all</em> Haml operators, whether requested 
at the operator level, or through <code>option:escape_html</code>, including an 
operator such as the Tilde or Ampersand expressions 
(<code>~ expr</code> and <code>&amp; expr</code>) and helper functions such as 
<code>helper:capture_html</code>, operating individually or in composition.</p>

<p>Note: Sanitizing user input is a separate matter: an input processor 
providing HamlSource <strong>should</strong> sanitize <em>input</em> of the form <code>&amp;amp;</code> 
to <code>&amp;amp;amp;</code>, which WSE Haml, while processing that HamlSource and 
generating HtmlOutput, will not further transform.</p></li>
<li><p>html_tabs </p>

<p>A new helper, yielding the count of 'tabs' in the current OutputIndent.</p></li>
<li><p>html_tabstring </p>

<p>A new helper, get/set the string used for a single 'tab' of the OutputIndent.</p></li>
</ul>

<p>As a quick preview of Haml with the WSE extensions, the following,
with varying indent and nesting, just works:</p>

<pre><code>
  Code 7.01

  %div#id1
      %p cblock2
      %p cblock3
  %div#id2
    %p cblock4
         cblock4 nested
</code></pre>

<p>As does this, which is the above, perhaps after a bit of maintenance,
exhibiting an undent that does not return to a prior level of
indentation:</p>

<pre><code>
  Code 7.02

  %div#id1
      %p cblock2
         cblock4 nested
      %p cblock3
    %p cblock4
</code></pre>

<p>In both cases, Haml sees what you mean, and creates spiffy HtmlOutput.</p>

<pre><code>
  &lt;div id='id1'&gt;
    &lt;p&gt;cblock2&lt;/p&gt;
    &lt;p&gt;cblock3&lt;/p&gt;
  &lt;/div&gt;
  &lt;div id='id2'&gt;
    &lt;p&gt;cblock4
      cblock4 nested
    &lt;/p&gt;
  &lt;/div&gt;


  &lt;div id='id1'&gt;
    &lt;p&gt;cblock2
      cblock4 nested
    &lt;/p&gt;
    &lt;p&gt;cblock3&lt;/p&gt;
    &lt;p&gt;cblock4&lt;/p&gt;
  &lt;/div&gt;
</code></pre>

<p>The above shows the extension of Mixed Content to a full ContentModel type,
with examples of the resulting rendered HtmlOutput showing the Inline
portion of the Content rendered immediately after any Html start tag.</p>

<p>Great ... but: the principles behind that change prompt a related change
to the rendering of an Inline Content ContentBlock having newlines, such as
can occur with interpolation, C<= expr>, or similar: like the above, the
initial whitespace, and the initial text is rendered immediately after any
Html start tag. For some Haml users, this will be WSE Haml's most obvious
departure from the Legacy Haml rendering.</p>

<pre><code>
  Code 7-03

  :strvar => "foo\nbar"

  %p
    = strvar
  &lt;p&gt;
    foo                        # Normalized indent, just as other cases
    bar
  &lt;/p&gt;

  %p= strvar                   # WSE Haml: Start my var's content tight
  &lt;p&gt;foo
    bar                        # Normalized indent, just as other cases
  &lt;/p&gt;

  %p eggs #{strvar} spam
  &lt;p&gt;eggs foo                  # Same mechanisms applied to previous case
     bar spam
  &lt;/p&gt;
</code></pre>

<p>These are taken from the Code 08-8 suite of sample code, below, which
contains further examples and discussion.</p>


<h2>Processing Model -- Haml Whitespace Semantics Extensions (WSE)</h2>

<p>This section walks through the processing model for whitespace, starting
mostly from guiding principles and the basic elements, and eventually 
moving to specific cases (to which you may be wise to directly skip).</p>

<p>Terms are introduced and explained in place. Please, however, see the 
<strong>Glossary</strong>: you should probably scan it first.</p>

<p>These extensions attempt to be neutral wrt implementation language. 
Be on your guard, however: the Ruby and Perl implementations 
evaluate certain Haml forms at different times and in different dynamic 
contexts. The processing of the results of interpolation is one such area.
It's possible some of that has snuck in here.</p>

<h3>Model of Lexing and Syntactics</h3>

<p>From the Haml Reference:</p>

<pre><code>  A substantial portion of any Html document is its content, 
  which is plain old text. ...
</code></pre>

<p>An important aspect of the WSE processing model wrt legacy Haml concerns
the model of lexical and syntactical analysis. With respect to lexing 
and syntactics, the legacy implementation (and language design) treats 
the challenge as, essentially, that of an executable language. 
Like Python, for example; but Haml is not Python. </p>

<p>That approach is a contributor to a confusion captured in the dispiriting 
meme: <em>Haml is for layout, not content</em>.</p>

<p>WSE recognizes the difference in these models, aligning lexing and syntax 
more with Haml's actual lexical and syntactical nature: as a macro language. </p>

<p>An executable language consists of, mostly, active constructs, 
statements and expressions, and such; all other content is narrowly 
constrained or contained. In a macro language the situation is reversed:
the focus is on content, of which macro languages are much more tolerant.
Basically, when a processor of macro languages is not operating directly 
on its own lexemes, it accepts anything. </p>

<p>Consider, for the starkest of examples, a random (unclosed) <code>#{...</code> or 
even <code>=1 + {</code>. Under the legacy implementation, the lexer fails and, 
consistent with an executable language approach, terminates the entire 
rendering (in a full Java-esq cascade of errors). Under WSE, the lexer 
(conceptually) runs to the end of the plausible branch, backtracks, 
and fires that construct as plaintext. </p>

<p>Legacy Haml generates an exception:</p>

<pre><code>
  Code 8.1-01

  %div
      %p #{varstr

  Haml::SyntaxError,/Unbalanced brackets/
</code></pre>

<p>In WSE Haml, a construct is plaintext unless it fully satisfies some
branch of the syntax:</p>

<pre><code>
  Code 8.1-02

  %div
      %p #{varstr

  &lt;div&gt;
    &lt;p&gt;#{varstr&lt;/p&gt;
  &lt;/div&gt;
</code></pre>

<p>That is but one, albeit stark, example of an overall effect. The change 
under WSE provides more expressive latitude for authors, less tedious 
hedge-trimming.</p>

<h3>Coarse Hierarchy of Constructs</h3>

<p>Another important aspect of the WSE processing model is the coarse-grained
hierarchy into which Haml constructs are divided. We consider these four 
divisions, with the lexer, the tree builders, and the interpreter/parser 
each dispatching the first-mentioned constructs earlier than the 
later-mentioned:</p>

<ul>
<li><p>Processing Instructions, such as encoding</p></li>
<li><p>Meta Constructs, including, for example: Haml Comments</p></li>
<li><p>Macros (Haml tags), Expressions, and Transforms</p></li>
<li><p>Content (e.g., plain text)</p></li>
</ul>

<p>The WSE model assumes the operation of a separate lexer and syntax
analysis, which builds an abstracted tree of the HamlSource. From 
this tree, WSE Haml forms an abstraction of the HamlSource semantics.</p>

<p>How is that significant? Consider for example the Multiline syntax. 
The related text arrives at the later code generation stages with the 
Multiline pipe lexeme <code>" |"</code> stripped. This sort of interpretation 
improves author predictability (the first semantic frame, from above), 
sets up an interpretation that parallels the other Haml constructs (the 
author can apply the same reasoning with regards to whitespace as if 
the syntax were the more usual Haml prefix syntax rather than infix) 
and control over included whitespace in the HtmlOutput (the second 
semantic frame) ... and makes sense of a bug fix (a nit) to the legacy 
Ruby implementation.</p>

<p>As an example of the significance of this hierarchical division, and of the
consequential operational model, consider Haml Comments (apart from their 
role as Processing Instruction). Starting at the bottom of the hierarchy, 
Haml Comments are transparent in Content. Moving upwards, Haml Comments are 
neither macro, expression or transform. Haml Comments are, in WSE, meta 
contructs -- they are one of the few Haml tags that describe the semantic 
nature of their accompanying ContentBlock. The semantic for 
Haml Comments: "ignore, entirely, me and my ContentBlock."</p>

<p>Changing to this processing model has two consequences. The most important:
Haml Comments are of lesser significance (in every semantic frame) than 
Whitelines (lines having only whitespace and a newline). Whitelines are 
content, they have a meaning, and they impact HtmlOutput structure and 
content; Haml Comments do not. The corollary: Haml Comments are semantically
invisible to every lower division. </p>

<p>One simple way this model and its consequences become concrete is with 
the Multiline syntax: Whitelines have salience; Haml Comments do not. 
That is, Haml Comments are semantically impotent (i.e., invisible, 
non-existent) at the point where content is synthesized into HtmlOutput. 
A Whiteline can, therefore, separate two blocks of Multiline syntax. 
This introduces a much more natural syntax, removing some cruft in the 
HamlSource ... at the cost of slight corner-case backward incompatibility 
in the format of the HtmlOutput (but not in the (X)HTML semantics of the 
HtmlOutput).</p>

<p>For example, under WSE Haml (modulo trailing and leading whitespace):</p>

<pre><code>
  Code 8.2-01

  %foo
    First |
    Block |

    Second |
    Block |

  &lt;foo&gt;
    First Block
    Second Block
  &lt;/foo&gt;
</code></pre>

<p>WSE Haml processing mode: by the time the Multiline ContentBlock is
processed, the Haml Comment is already removed:</p>

<pre><code>
  Code 8.2-02

  %foo
    First |
    Block |
    -# Haml Comment    # WSE processing model changes the AST
    Second |
    Block |

  &lt;foo&gt;
    First Block Second Block
  &lt;/foo&gt;
</code></pre>

<p>While we are here considering Multiline, a related way in which the 
WSE processing model changes the semantics of Whitelines (of that
second semantic frame) -- multiple Whitelines are consolidated to 
a single Whiteline:</p>

<pre><code>
  Code 8.2-03

  %foo
    First |
    Block |



    Second |
    Block |

  &lt;foo&gt;
    First Block

    Second Block
  &lt;/foo&gt;
</code></pre>

<p>Finally, under WSE Haml, a Whiteline will terminate the Nested ContentBlock 
of a Haml Comment. This is discussed in greater detail below.</p>

<h3>Elements</h3>

<p>An Element:</p>

<pre><code>
  Code 8.3-01

  %p
    Text
</code></pre>

<p>In shorthand, an Element is some Haml token, and its content. More formally, 
an Element prompts a state change in the parser syntax tree.</p>

<p>Similar to XML, the HamlSource document is the root; in Haml all Elements 
appearing (in effect) at any given column index, including the first column,
are siblings.</p>

<p>Each Element is a collection of tokens describing the Head and a (possibly
null) ContentBlock, which follows some Content Model.</p>

<p>In Haml, the tokens that comprise an Element Head includes levels of 
indentation. Made explicit, with '.' representing indentation, an Element
Head of '<code>....%span</code>' below an Element Head of '<code>..%p</code>' describes a parent-child
relationship.</p>

<pre><code>
  Code 8.3-02

  ..%p 
  ....cblock1
  ....%span cblock2

  &lt;p&gt;
    cblock1
    &lt;span&gt;cblock2&lt;/span&gt;
  &lt;/p&gt;
</code></pre>

<p>A line's indentation is significant in determining its membership in a 
ContentBlock.</p>

<p>A Whiteline is a line containing the final \n with zero or more whitespace
characters preceding: a linespace or (if devoid of characters except the \n)
a blank line. </p>

<p>(The qualified name for it's complement is 'Textline', or 'Non-Whiteline'. 
When the distinction is irrelevant, both are just 'Line'.) </p>

<p>Whitelines can be significant in determining the extent of an Element and its 
ContentBlock.</p>

<p>In general, HamlSource is expected to yield an Html document, although (apart 
from the exigencies of parsing, and limited consideration for attribute and
tag syntax, and character sets) no document model or Html element content
model is enforced for the HamlSource nor for the resulting Html. The (current)
sole exceptions are:</p>

<ul>
<li><p>Encoding</p>

<p>Encoding may be specified by a processing instruction (in Haml Comment
syntax) at the beginning of the HamlSource.</p></li>
<li><p>Special character escaping</p>

<p>Escaping of the 'fifth' special character, apostrophe, is, under WSE,
limited to documents using an effective XML-related doctype or escaping 
option. Additionally, the (WSE-corrected) <code>filter:escaped</code> (alias:
<code>filter:escapehtml</code>) will perform the same processing wrt those special
characters.</p></li>
</ul>

<h3>Indentation</h3>

<p>Indentation is a measure: the column index of the first non-whitespace 
character following a prior newline.</p>

<p>After processing instructions, the first non-whitespace character of
a HamlSource must have an Indentation of 0.</p>

<p>Note: This is a discussion concerning HamlSource. Regardless of these 
concerns, when HtmlOutput is generated the size of each OutputIndent 
is a fixed size: by convention 2 spaces, and get/set-able by helper 
<code>html_tabstring</code>, a WSE extension. The number of OutputIndents to be 
used when next needed is get-able by (WSE extension) helper <code>html_tabs</code>
and modifiable by helpers <code>tab_up</code>, <code>tab_down</code>, <code>with_tabs</code>.</p>

<p>This section will touch on several fundamental concepts. They include:</p>

<ul>
<li><p>The Indentation measure</p></li>
<li><p>The Offside Rule</p></li>
<li><p>The IndentStep, Indent, and Undent</p></li>
<li><p>The Orderly Indentation Rule</p></li>
<li><p>The BlockLeftMargin</p></li>
</ul>

<p>Indentation in HamlSource is of primary significance in determining
the scope of a ContentBlock. It is not the only consideration. 
To a smaller extent, e.g., Whitelines are also significant.</p>

<p>In consequence, Haml is a physical ISWIM language observing the general rule 
that a construct be defined in its "southeast quadrant", which gives rise to 
the Offside Rule [4]: Indentation is used to indicate program structure.</p>

<p>Landin defined ISWIM as a four-level concept. With respect to getting 
concepts clear, Python is also a physical (level-1) ISWIM language, 
but is a realization of a narrowed, parochial, interpretation of the 
general abstract (level-3) ISWIM concepts. That's for good effect. 
Legacy Haml, however, hardened Python's interpretation by insisting 
that the indent be everywhere constant (say, 2 spaces). This is 
unnecessary for Haml.</p>

<p>Under default WSE Haml the rule is, just: Stay to the Right.</p>

<p>This abstract example shows a constant 2-space indent (the <strong>IndentStep</strong>)
throughout. It is compatible with legacy Haml implementations.</p>

<pre><code>
  Code 8.4-01

  HEAD1
   HEAD2
     HEAD3
       Content1
       Content2
   UNDENTLINE
</code></pre>

<p>The following example observes the same rules. Below we'll annotate and 
adjust it to demonstrate several aspects of WSE Haml.</p>

<pre><code>
  Code 8.4-02

  ..%div#id1
  ....%p cblock1
  ....%div#a
  ......%p cblock2
  ......%p
  ........cblock3
  ..%div#id2
  ....%p cblock4
</code></pre>

<p>Such indentation describes the tree: In legacy Haml a child is indented 
by a single IndentStep from its parent; siblings (and cohort cousins) 
have the same IndentStep count (number of identically-sized IndentSteps).</p>

<p>The unadorned general abstract (level-3) ISWIM concepts offer more
flexibility: given that a construct's definition is onside (indented to 
the construct's right), the rules for its interior nesting are unspecified, 
and may vary by physical ISWIM language implementation.</p>

<p>As an ISWIM language, WSE Haml implements these more general abstract-level
concepts. WSE Haml calls its nesting rule the Orderly Indentation Rule (OIR). </p>

<p>WSE Haml provides three OIR modes: <em>unobserved</em>, <em>strict</em>, and <em>loose</em>.</p>

<p>Not all Haml constructs observe OIR: for example, the Multiline syntax.
Most constructs do observe the OIR. The 'strict' mode of OIR will enforce 
a slightly relaxed form of the legacy indentation rules. </p>

<p>Under <em>OIR:strict</em>, the IndentStep must be constant <em>within an Element's 
immediate ContentBlock</em>. Under <em>OIR:strict</em>, the following is allowed. 
Notice the changing size of the IndentStep (some might say it allows
improved cosmetics in HamlSource):</p>

<pre><code>
  Code 8.4-03

  ..%div#id1
  .....%div#a cblock1
  .....%div#b
  .........cblock2
  .........%p
  ............cblock3
  ..%div#id2
  ......%p cblock4
</code></pre>

<p>Under <em>OIR:strict</em>, an Undent must 'unfold' (or 'pop') some number of the 
preceding IndentSteps to return to the column of a prior indent, as 
with <code>%div#id2</code>.</p>

<p>Imagine that maintenance called for removing most of <code>%div#b</code>, deleting
<code>cblock2</code> and the <code>%p</code> element, leaving only the <code>cblock3</code> content. The 
following also would conform to <em>OIR:strict</em>:</p>

<pre><code>
  Code 8.4-04

  ..%div#id1
  .....%div#a cblock1
  .....%div#b
  ............cblock3
  ..%div#id2
  ......%p cblock4
</code></pre>

<p>Here, in the resulting tree, despite differences in the size of the 
IndentStep, <code>%div#a</code> and <code>%p cblock4</code> are at the same level: first 
cousins.</p>

<p>The default for WSE Haml is, however, <em>OIR:loose</em>, to which the following,
perhaps after further maintenance, would conform (Yes, not a typo: the 
Indentation of <code>%p cblock4</code> is only one more than that of <code>%div#b</code>.):</p>

<pre><code>
  Code 8.4-05

  ..%div#id1
  .....%div#a cblock1
  .....%div#b
  ............cblock3
  ......%p cblock4
</code></pre>

<p>For the concrete implementation of a general, abstract (level-3) ISWIM 
language, like WSE Haml, there is only one, unambiguous, interpretation of 
this HamlSource, for any Offside Rule-compliant substitution for <code>cblock3</code> 
or <code>%p cblock4</code>: they are siblings. Haml gives:</p>

<pre><code>
  &lt;div id='id1'&gt;
    &lt;div id='a'&gt;cblock1&lt;/div&gt;
    &lt;div id='b'&gt;
      cblock3
      &lt;p&gt;cblock4&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</code></pre>

<p>(This demonstrates how the case discussed in Haml github issue 28 is,
under <em>OIR:loose</em>, unambiguously resolved for any Offside Rule-compliant 
substitution of the two lines: the two descendants are siblings.)</p>

<p>The example above gives occasion to clarify a few related concepts. </p>

<p>To put it into operation, "offside" requires a point of reference. For WSE
this point of reference is called the BlockLeftMargin (BLM). The BLM falls
at the minimum Indentation which contains the complete definition of the 
related Element. At minimum, the Indentation for an Element's BLM
equals the Head's Indentation + 1.</p>

<pre><code>
  ..%div#id1
  .....%div#a cblock1
  .....%div#b
  ............cblock3
  ......%p cblock4

        ^
        | BlockLeftMargin for `%div#b` (OIR:loose)
</code></pre>

<p>Under <em>OIR:strict</em>, the IndentSteps under an immediate Element will be
constant: the Textlines will demarcate a single clear column. </p>

<p>Under <em>OIR:loose</em>, however, the size of the IndentStep may vary even within 
the immediate Element.</p>

<pre><code>
  ..%div#id1
  .....%div#a cblock1
  .....%div#b
  ............cblock3
  ......%p cblock4

  ..            IndentStep=2  for `%div#id1`
    ...         IndentStep=3  for `%div#a` and `%div#b` 
    ....        IndentStep=4  for `%p cblock4`
    ..........  IndentStep=10 for `%p cblock4` 
</code></pre>

<p>Offside is part of a state change too. A Textline is considered Onside
when it's Indentation is equal or greater than an Element's BLM; otherwise
it is Offside. A Textline is said to have 'moved' Offside when it appears
as the first Textline to have Indentation less than the prevailing BLM
(with 'moved' Onside as a rare description of the inverse case).</p>

<p>Still in <em>OIR:loose</em> (the default):</p>

<pre><code>
  Code 8.4-06

  0 00 000    1
  0 23 567    2
  ..%div#id1
  .....%div#a cblock1
  .....%div#b
  ............cblock3
  ......%p cblock4
  .....%div#id2

        ^
        | BlockLeftMargin for `%div#b` (OIR:loose) (Indentation=6)
       ^
       |  Offside move, for Textline `%div#id2` (Indentation=5)
     ^
     |    BlockLeftMargin for `%div#id1` (Indentation=3)
</code></pre>

<p>Notice in the above that the smallest Undent for Textline <code>%div#id2</code> shifts 
it Offside into the <code>%div#id1</code> ContentBlock, as a sibling. Any move offside
Undent between Indentation 5 and 3 would have had the same result.</p>

<p>In a HamlSource describing an ordinary HTML document, after the encoding PI, 
and doctype macros, it would be most common for most Textlines to never go 
Offside past the second BlockLeftMargin (here, demarcated by CONTENT): </p>

<pre><code>
  Code 8.4-07

  0 2 4
  %html
    %head
    %body
      CONTENT
</code></pre>

<p>There is, of course, the potential for a variety of HamlSource whitespace
forms which result in different treatments, such as those for Multiline or 
HereDocs. Also, there is a variety of HtmlOutput whitespace forms, 
including a difference under <code>option:preserve</code> or <code>option:preformatted</code>.</p>

<p>In summary of the basic indentation rules:</p>

<ul>
<li><p>Legacy </p>

<p>IndentSteps are constant throughout</p></li>
<li><p>OIR:strict </p>

<p>IndentSteps must be the same within an immediate Element. 
Undents must unfold (pop) some number of prior IndentSteps.</p></li>
<li><p>OIR:loose </p>

<p>IndentSteps may vary within an immediate Element, provided
they stay Onside: with Indentation equal or greater-than that
of the prevailing BLM.</p></li>
</ul>

<p>Exceptions to the above arise with certain specific structures. Some
of the annotations are rather cryptic or are introduced here for the
first time. Refer to descriptions later in this document.</p>

<pre><code>             Observe  Require
             Offside  OIR      Notes
  ---------  -------  -------  ------------------------------------------------------------------

  !!!           Yes    n/a     Inline-only
  -code         Yes    n/a     Inline-only
  =expr et al   Yes    n/a     Inline-only(embedded \n*); Interpolation; no %tags;
  ~expr         Yes    n/a     Inline-only(embedded \n*); Interp.; no %tags; preserve transform
  Plaintext     Yes    n/a     Just line-by-line; Interpolation

  Multiline     No     No      Infix lexeme; %tags &amp; Interpolation; Consolidate Whitespace
  HereDoc       No     No      Terminal lexeme; Interpolation; Verbatim Whitespace

  Haml Comment  Yes    No      Meta content; In addition to Offside, Whiteline terminates too
  Html Comment  Yes    No      Haml processing (%tags, interpolation, etc)

  preformatted  Yes    Free    %tag listed in option; Haml processing; Verbatim
  preserve      Yes    Legacy  %tag listed in option; Haml processing; Transform newlines

  filters       Yes    No      For the Filter Head; Each filter then has its own content rules

  :preserve     Preset No      Within the Filter ContentBlock, the rules for this filter set the 
                               BLM at parent's IndentStep; within that OIR is not required. 
                               Preserve transform; Interpolation; no %tags

  :preformatted No     No      The BLM is set to the minimum indent, at the :preformatted 
                               Indentation plus 1. 
                               No newline transform; Interpolation; no %tags

  Haml %tag     Yes    Yes     Haml processing; OIR:loose (default) or OIR:strict

  * embedded \n: Operator permits expression having embedded newline (which it interprets)

  ----
  Observe Offside: Is the extent of the Content Model of the specified 
      ContentBlock sensitive to the BLM and Offside Undents? An Inline-only 
      Content Model is by definition Offside sensitive (plaintext TextLine, 
      etc.); A Content Model whose extent is insensitive to the BLM and 
      Offside Undents will require something other than these effects to 
      terminate the ContentBlock (e.g., Multiline: the absence of the infix 
      lexeme; HereDoc: the presence of the specified terminal string).
  Require OIR: Does the Content Model of the specified ContentBlock 
      enforce the OIR (strict, or loose) for it's content? This impacts
      nested tags, as you'd expect. But it also impacts author expectations 
      related to plaintext. For example, legacy Haml disallows indentation 
      in plaintext. Mysterious-enough for an ordinary tag, but it comes as
      a surprise to an author attempting to use an option:preserve tag with 
      nested content (sure, Haml jocks have learned that this is improper), 
      who is told: [just] use filter:preserve [after indenting every line of
      the entire text another IndentStep]. Under WSE Haml, tags follow 
      `OIR:loose` by default, and tags listed in `option:preformatted` allow 
      indentation in plaintext.
</code></pre>

<p>For more examples, see the RSpec test cases.</p>

<ul>
<li>[4] P. J. Landin ACM v9 n3, Mar 1966, p157. "Offside" is the spelling on 
  p160, where it is actually defined (p164 spells it "off-side"). 
  Merriam-Webster's Collegiate 10th lists it as "offside". Good enough for 
  me ... I invite you to (try to) correct the various Wikipedia entries.
  Landin proposed ISWIM <em>If you See What I Mean</em> as the name for the 
  family of languages realizing the described system.</li>
</ul>

<h3>Four Content Models</h3>

<p>There are (broadly speaking) four types of Content Models:</p>

<ul>
<li><p>Inline Content ('On-the-line') </p>

<p>In the <em>Inline Content</em> Content Model, the ContentBlock appears on the same 
line as the Head: a %tag, or '= expr' or '- code' or similar.</p></li>
<li><p>Nested Content </p>

<p>In the <em>Nested Content</em> Content Model, the ContentBlock starts not on the 
line with the Head but on the next Textline, at increased indentation from
the Head. (If Inline Content is also present the entire ContentBlock is
called <em>Mixed Content</em>, q.v.)  Unless otherwise noted, an Element supporting <em>Nested Content</em> permits
additional, nested, Elements; otherwise it is said to support (only)
<em>Nested Text Content</em> (which may enforce a single BlockLeftMargin, or
alternatively permit additional indentation).</p></li>
<li><p>Mixed Content </p>

<p>Where the <em>Mixed Content</em> Content Model is permitted, the ContentBlock may
start on the Head (Inline), and continue below on the next Textline, indented
(Nested). Where Mixed Content is permitted, either <em>Inline Content</em> alone 
or <em>Nested Content</em> alone may be used. Wider support of <em>Mixed Content</em>,
and the related formats for HtmlOutput, is one of the key extensions in 
WSE Haml.</p></li>
<li><p>HereDoc Content </p>

<p>Where the <em>HereDoc Content</em> Content Model is permitted, that Element's 
ContentBlock starts at Indentation 0 of the Line following the Head line 
that contains the Initial HereDoc Delimiter of alphanumeric-plus-underscore 
characters (/&lt;&lt;-?[\w_]+/). The Element's ContentBlock ends with the 
newline of the last Line before the Terminating HereDoc Delimiter. If the 
Initial HereDoc Delimiter begins with the form '&lt;&lt;-', the Terminating 
HereDoc Delimiter may be indented.</p>

<p>Within HereDoc Content, the Orderly Indentation Rule and BlockLeftMargin
effects (including Offside) are suspended. Interpolation is provided,
but ordinary Haml tags and other processing is not provided. </p>

<p>(For those familiar with Ruby HereDoc, the WSE Haml implementation is 
similar to the interpolating HereDoc (with double-quotes, or bare) ... 
but quotes marks are not supported in the WSE Haml HereDoc syntax.)</p>

<p>Where an Element supports HereDocs, the resulting ContentBlock (after 
interpretation, including interpolation) is valid for any type of 
Content Model (Inline, Nested, or Mixed). If, for example, the Element's 
Head is listed in <code>option:preserve</code>, the standard preserve transformations 
will be applied to assure 'preserve'-compliant HtmlOutput.</p>

<p>Any Textlines following the Line containing the Terminating HereDoc 
Delimiter is evaluated as part of the parent or ancestors of the Element
to which the HereDoc provides the ContentBlock (i.e., the Textline is 
the Element's sibling or a cousin, depending on OIR.)</p>

<p>TODO: The <code>&lt;&lt;EOD</code> provides the entire ContentBlock. Perhaps the Initial 
HereDoc Delimiter could be followed by something? Whatever that could be,
it would not be part of the ContentBlock--it would seem appropriate to
apply to the Head or the Element overall. Perhaps it could be text, such
as <code>&lt;&lt;EOD.</code> or <code>&lt;&lt;EOD  *</code>, which would be appended to the HtmlOutput for the
Element, ala <code>helper:succeed</code>. See the RSpec suite for exploration of
this.</p></li>
</ul>

<p>These content models, and variations, are described further below.</p>

<h3>Whitespace (Horizontal whitespace)</h3>

<p>Indentation is the most significant whitespace, it pertains to HamlSource 
syntax and semantics. But there are other whitespace considerations, 
including some pertaining to HtmlOutput, as follows.</p>

<p>WSE Haml approaches Whitespace using three transforms:</p>

<ul>
<li><p>Replay (null transform, after IndentStep/syntax adjustment)</p></li>
<li><p>Consolidate (transform n->1)</p></li>
<li><p>Remove (transform n->0)</p></li>
</ul>

<p>The four categories of Whitespace in WSE Haml are <em>Initial</em>, <em>Leading</em>, 
<em>Interior</em>, and <em>Trailing</em>.</p>

<ul>
<li><p>Trailing Whitespace</p>

<p>Trailing whitespace has no semantic significance to Haml. Further,
in all but a few cases it is removed from HtmlOutput, or in 
the few exceptions, it is consolidated.</p>

<p>Trailing whitespace is replayed under <code>option:preserve</code> and 
<code>option:preformatted</code>, within filter:preserve, and in HereDoc; 
it is consolidated in Multiline text.</p>

<p>Notice that under WSE, "preserve" is changed to consolidate trailing 
newlines in an expression (that is, the "="-equiv constructs), 
then transform the single remaining newline. </p>

<p>In Multiline Content Blocks, Trailing Whitespace is consolidated.</p></li>
<li><p>Interior Whitespace</p>

<p>The interior linear whitespace of ordinary HamlSource Textlines is 
replayed (n->n).</p>

<p>TODO: Possible option wspcinterior:consolidate ?</p></li>
<li><p>Leading Whitespace</p>

<p>This category refers to whitespace at the beginning of each Textline
in Nested Content, distinguishing it from Initial Whitespace (see below).</p>

<p>Leading Whitespace refers to the Whitespace in the HamlSource remaining 
after adjusting for any IndentSteps: those of the ancestor Elements, and 
of the Head--it is the whitespace between the ContentBlock's 
BlockLeftMargin and the beginning of the Textline.</p>

<p>Leading Whitespace is replayed. Exceptions to this include the Multiline
syntax.</p></li>
<li><p>Initial Whitespace</p>

<p>Initial Whitespace is present when an author has started the first Textline 
of an Element's ContentBlock with Whitespace: whether on Inline Content,
or when the first Textline is in a Nested Content ContentBlock.</p>

<p>WSE honors the author's action: Initial Whitespace is replayed to HtmlOutput.</p>

<p>In plaintext content (for tags <em>not</em> listed in <code>option:preserve</code> or 
<code>option:preformatted</code>, or without expressions, for example), there can be 
no Initial Whitespace in Inline Content: the gap between the Haml lexeme and 
the plaintext is just part of the syntax.</p>

<p>Initial Whitespace can arise, however, where the Inline Content is an 
expression or the Inline Content begins with interpolation, or for tags 
listed in <code>option:preserve</code> or <code>option:preformatted</code>. </p>

<p>For Haml tags listed in <code>option:preserve</code> or <code>option:preformatted</code>) the 
Head is removed, including the single required space (e.g., "%pre "): any 
remaining whitespace before plaintext is considered part of the ContentBlock, 
to be replayed to HtmlOutput (preserved). Initial Whitespace is replayed 
after the proper OutputIndent is emitted (i.e., the Initial Whitespace is
appended to the OutputIndent). </p>

<p>Where the Initial Whitespace appears through a string, or interpolated 
value, that whitespace is replayed.</p></li>
</ul>

<h3>Styles of Specifying and Preserving HamlSource Whitespace</h3>

<p>Haml features facilities that enables an author to produce HtmlOutput that,
to varying extent, retains the surface structure of the HamlSource. 
Think Html &lt;pre&gt;, in varying flavors.</p>

<p>Implementation note: The method by which such surface structure is retained
or represented during processing is implementation-dependent, only the
form (including encoding) of the HtmlOutput is assured.</p>

<p>Legacy Haml offers these <em>preserve</em> facilities:</p>

<ul>
<li><p>helper:find_and_preserve, for contained <ptag></ptag> where <em>ptag</em> is included in option:preserve.</p></li>
<li><p>expression:~ (Tilde) alias for find_and_preserve</p></li>
<li><p>hamltag:%ptag, where <code>ptag</code> is listed in option:preserve</p></li>
<li><p>helper:preserve</p></li>
<li><p>filter:preserve</p></li>
</ul>

<p>Note that these break down to two main facilities: the <strong>FAP Facility</strong> 
for Inline Content (which might more fully be called 
<code>reencode_interior_newlines_occurring_between_listed_html_elements</code>),
and the <strong>General Newline Transform facility</strong> for Inline or Nested Content.</p>

<p>The main concerns for Haml authors of such facilities: the ContentBlock,
the transformation to HtmlOutput, and any restrictions to Haml, as follows:</p>

<ul>
<li><p>What types of ContentBlock?</p></li>
<li><p>Restrictions on indentation for ContentBlock?</p></li>
<li><p>How are newlines transformed? A.k.a: How is <em>preserve</em> accomplished?</p></li>
<li><p>How is whitespace transformed in from HamlSource to HtmlOutput?</p></li>
<li><p>Interaction with escaping of Html?</p></li>
<li><p>Interaction with, or prohibition of, other Haml operators and constructs?</p></li>
</ul>

<p>WSE Haml extends the legacy facilities to attempt to <em>complete</em> the set of
whitespace-preserving operators and mechanisms, with <code>option:preformatted</code>, 
and HereDocs.</p>

<p>The following tables show how the above-listed concerns are addressed by 
legacy Haml plus the WSE extensions. </p>

<p>Nomenclature: Just as <em>ptag</em> denotes (above) a tag listed in 
<code>option:preserve</code> (<em>p</em> as in preserve), <em>vtag</em> denotes a tag listed 
in the WSE extension <code>option:preformatted</code> (that's <em>v</em> for <em>verbatim</em>).
Also, <em>H:preserve</em> refers to the helper function <code>=preserve()</code>; the 
<em>F:preserve</em> refers to the filter operator <code>:preserve</code>.</p>

<pre><code>  ContentBlock
  Inline         Nested         Mixed permitted
  ----------     ----------     ------------------
  FAP            F:preserve
  Tilde               
  ptag           vtag *         vtag
  H:preserve     
                 HereDoc *

  * New in WSE Haml


  Newline Treatment
  Transform \n to &amp;#x000A;                 Emit \n
  -------------------------------------    -------------
  Only in &lt;ptag&gt;&lt;/ptag&gt;     All Content    All Content
  ----------------------    -----------    -------------
  FAP                       F:preserve     HereDoc 
  Tilde                     ptag           vtag
                            H:preserve


  Observe and Enforce Offsides, Indentation
                        Offside for     OIR in
  Facility      n/a     ContentBlock    ContentBlock         OutputIndent
  ----------   ------   ------------    -----------------    ---------------------
  FAP            x                                           Head
  Tilde          x                                           Head
  ptag           x                                           Head
  H:preserve     x                                           Head
  vtag                  Observed        OIR:strict,loose     Relative to Head BLM
  F:preserve            Observed        Free Indentation *   Relative to Head BLM
  HereDoc               NOT Observed    Free Indentation     Absolute

  * Note on F:preserve: that particular combination of Offside plus OIR permits 
    Free Indentation, provided the ContentBlock remains Onside of the Head --
    that is, the author must align the Textlines under the :preserve head.
</code></pre>

<p>Note that all of these facilities permit interpolation (although each 
differ in the interpretation of embedded whitespace or newlines introduced
by dynamic variables), and none will operate on other contained Haml 
(i.e., <code>%atag</code> is replayed as the string <em>%atag</em>).</p>

<p>Using these tables we can summarize the benefits an author might seek
in the related WSE Haml extensions:</p>

<ul>
<li><p><code>%vtag</code> over <code>%ptag</code></p>

<p>Nested ContentBlock, including plaintext; and \n on HtmlOutput</p></li>
<li><p><code>%vtag</code> over <code>f:preserve</code></p>

<p>HamlSource as normal tag (whose preserve-effect can be enabled/disabled); and \n on HtmlOutput</p></li>
<li><p><code>HereDoc</code> over <code>f:preserve</code></p>

<p>HamlSource is raw source; HtmlOutput is verbatim replication, with \n</p></li>
</ul>

<h3>Normalizing HtmlOutput Whitespace and Indentation</h3>

<p>The WSE extensions for Mixed Content, and relaxed indentation, offer authors
a bit of flexibility and even clearer code. But what about the related
domain, that of HtmlOutput? For example, how shall this (newly-permitted in
WSE Haml) be rendered?</p>

<pre><code>
  Code 8.8-01

  .flow
    %p Inline content
       Nested content
</code></pre>

<p>Haml with WSE proposes we honor author choices:</p>

<pre><code>
  &lt;div class='flow'&gt;
    &lt;p&gt;Inline content
      Nested content
    &lt;/p&gt;
  &lt;/div&gt;
</code></pre>

<p>There are other justifications too. One is that there is simply no other 
direct way (short of initial surprises in the output, and digging around 
for operator magic, and adding that cruft to the HamlSource)  for an author 
to accomplish that result. Another justification rests on minimizing the 
memory load for authors -- minimizing the variety in manipulations of their 
HamlSource.</p>

<p>Consider this (in legacy Haml, modulo whitespace bugs):</p>

<pre><code>
  Code 8.8-02

  %p First line  |
     Second line |

  &lt;p&gt;First line Second line&lt;/p&gt;
</code></pre>

<p>Multiline is a bit special, so let's consider instead the assumption that
the Haml author might not be in full control of the content (or may feel
the need to provide the quoted string directly in the Haml source). The 
Haml Reference calls this "dynamically-generated":</p>

<p>In legacy Haml (without resorting to the whitespace removal trim_in/out 
cruft), the HtmlOutput processor imposes a change in surface structure:</p>

<pre><code>
  Code 8.8-03

  - strvar = "foo bar"
  %p= strvar
  &lt;p&gt;foo bar&lt;/p&gt;

  - strvar = "foo\nbar"
  %p= strvar
  &lt;p&gt;                           # Legacy Haml forces nesting for first line
    foo
    bar
  &lt;/p&gt;

  - strvar = "foo\nbar"
  %p eggs #{strvar} spam
  &lt;p&gt;
    eggs foo
    bar spam
  &lt;/p&gt;
</code></pre>

<p>The surprises are reduced under Haml with the WSE extensions, without the
need for the find_and_preserve cruft:</p>

<pre><code>
  Code 8.8-04

  - strvar = "foobar"
  %p
    = strvar                  # WSE Haml: Always nest my var's content
  &lt;p&gt;
    foobar
  &lt;/p&gt;

  - strvar = "foo\nbar"
  %p
    = strvar
  &lt;p&gt;
    foo                        # Normalized indent, just as other cases
    bar
  &lt;/p&gt;

  - strvar = "foo\nbar"
  %p= strvar                   # WSE Haml: Start my var's content tight
  &lt;p&gt;foo
    bar                        # Normalized indent, just as other cases
  &lt;/p&gt;
</code></pre>

<p>These cases lead to the more general cases.</p>

<p>The simple case is where plaintext Inline Content begins after some number 
of intervening spaces after the Haml tag. In this case, regardless of the
presence of Nested Content (aka Mixed Content), the intervening spaces
are considered part of the syntax, they are removed and no OutputIndent 
is inserted.</p>

<p>The case open to more author confusion and surprise is where the 
Inline Content begins with quoted or interpolated material having
Initial Whitespaces.</p>

<pre><code>
  Code 8.8-05

  - strvar = "  foo\n   bar"
  %p= strvar
  &lt;p&gt;
      foo                       # Legacy Haml
       bar      
  &lt;/p&gt;
</code></pre>

<p>WSE Haml handling of Initial Whitespace in quoted or interpolated material:</p>

<pre><code>
  Code 8.8-06

  %p= strvar
  &lt;p&gt;  foo                      # WSE Haml
       bar      
  &lt;/p&gt;
</code></pre>

<p>When the tag is a member of <code>option:preserve</code> or <code>option:preformatted</code> the
extension in WSE Haml is to replay the author's input, <em>preserving</em> the
Initial Whitespace:</p>

<pre><code>
  Code 8.8-07

  :preserve =&gt; ['code']
  .quux
    - strvar = "   foo\n   bar"
    %code= strvar

  &lt;div class='quux'&gt;\n  &lt;code&gt;foo ...       # Legacy Haml fails to preserve
</code></pre>

<p>WSE Haml replays the Initial Whitespace:</p>

<pre><code>
  Code 8.8-08

  .quux
    %code= strvar

  &lt;div class='quux'&gt;\n  &lt;code&gt;   foo ...    # WSE Haml replays the Initial Whitespace
</code></pre>

<p>For Html preformatted tags, the WSE Haml result will be rendered
differently, which presumably was the author's intention. </p>

<p>Next we look at the generated Html endtag for the same type of preserve 
element, one containing a newline that's been <em>preserve</em>d. In this case,
WSE Haml normalization produces HtmlOutput with a slight improvement
in its correspondence to the author's HamlSource: Trailing Whitespace is 
replayed, even if trailed by newlines; any number of final newlines are 
consolidated into a single instance, and transformed (so, I guess that's 
a change from elision to surjection). The result will not produce a 
difference in the rendering by an Html- or CSS-conformant renderer, unless
by author CSS control ... which would now be possible.</p>

<pre><code>
  Code 8.8-09

  .quux
    - strvar = "   foo\n   bar  \n\n"
    %code= strvar

  &lt;div class='quux'&gt;                            # Legacy Haml fails to preserve
    &lt;code&gt;foo&amp;#x000A;   bar&lt;/code&gt;
  &lt;/div&gt;
</code></pre>

<p>WSE Haml consolidates the trailing newlines, then transforms:</p>

<pre><code>
  Code 8.8-10

  .quux
    - strvar = "   foo\n   bar  \n\n"
    %code= strvar

  &lt;div class='quux'&gt;                            # WSE Haml
    &lt;code&gt;   foo&amp;#x000A;   bar  &amp;#x000A&lt;/code&gt;
  &lt;/div&gt;
</code></pre>

<p>Here we see that the Trailing Whitespace is replayed, and the trailing
newlines are replayed <em>without transform</em>. That will format the HtmlOutput
so the matching endtag <strong></code></strong> will appear symmetrically aligned 
to the starttag.</p>

<pre><code>  HtmlOutput:
  &lt;div class='quux'&gt;&lt;code&gt;  foo&amp;#x000A;   bar  &amp;#x000A;&lt;/code&gt;\n

  Native Html equivalent:
  &lt;code&gt;  foo
     bar  
  &lt;/code&gt;

  HTML/CSS-Conformant UA rendering:
     foo
     bar
</code></pre>

<p>Any number of such trailing newlines will be transformed in this way, 
including when only newlines comprise the content. </p>

<p>Also, for clarity concerning Initial Whitespace and tags listed in option
preserve/preformatted: when creating the AST for Elements not beginning
with variables or interpolation, Haml should capture the Initial Whitespace 
after the tag the associated, obligatory, single whitespace. (And, of course,
trailing whitespace: in the example below there is also Trailing Whitespace 
of two spaces.)</p>

<pre><code>
  Code 8.8-11

  :preserve =&gt; ['code']
  %code   Foobar               # Notice: "%code " and "  Foobar  "

  &lt;code&gt;  Foobar  &lt;/code&gt;      # WSE Haml, notice 2 space Initial WSPC
</code></pre>

<p>Inline Content for Html Comments is subject to the same rules as an ordinary 
tag, but be sure to read more about Haml Comments, below.</p>

<p>Initial space in Nested Content is also honored, as above. In the nested 
lines of Mixed Content, however, the space at the left of the Textline 
(leading whitespace) is taken as an IndentStep ... so any whitespace in 
addition to that must be provided through expression or interpolation.</p>

<pre><code>
  Code 8.8-12

  :preserve =&gt; ['code']
  - strvar = "   foo\n     bar  \n"
  %code= strvar
  %cope= strvar               # Arbitrary tag

  &lt;code&gt;   foo&amp;#x000A;     bar  \n&lt;/code&gt;
  &lt;cope&gt;                       # Non-option:preserve tag 
    foo
    bar                        # WSE Haml, Notice: only 1 OutputIndentStep
  &lt;/cope&gt;
</code></pre>

<p>When a preserve or preformatted tag contains only whitespace, the whitespace
is replayed.</p>

<h3>Whitelines (Vertical whitespace)</h3>

<p>A Whiteline is a line containing a final \n with zero or more preceding 
whitespace characters. Also known as a linespace, or (if devoid of 
characters except for the \n) a blank line.</p>

<p>Just as with a Textline, a Whiteline falls within the scope of an Element. 
By convention, a Whiteline is assigned an Indentation measure drawn from
that Element's content: the Indentation of the preceding Textline, or if
none, the Indentation of the following Textline.</p>

<p>Inline Content cannot, of course, have Whitelines. </p>

<p>Elements having Nested Content may have Whitelines. Initial Whitelines are 
removed. Single Whitelines occurring at the end of the scope of an Element
(trailing Whitelines) or within an Element (interior Whitelines) are removed.
Multiple trailing Whitelines, and multiple interior Whitelines are 
consolidated (n -> 1).</p>

<p>The ContentBlock of a Haml Comment is terminated by a Whiteline (as well 
as the usual Offsides); see more about the Haml Comment model, below.</p>

<p>These mechanics provide an author the means to control HtmlOutput line
spacing. Such control is useful in literal text, but also where content
will be interpolated or computed, including possibly null productions.</p>

<pre><code>
  Code 8.9-01

  %div
    %p cblock1
    %p
                     # Leading Whiteline is removed
       cblock2a      
                     # Multiple Interior Whitelines are consolidated


       cblock2b      
                     # Single Interior Whitelines are removed
       cblock2c
                     # Multiple Trailing Whitelines are consolidated

    %p cblock3

    %p cblock4inline   # Inline content for Mixed Content ContentBlock         
       cblock4a
        -#             # Inserted into Nested Content -- a Haml Comment
         cblock4c      # Captured by Haml Comment as Nested Content ContentBlock
                       # Whiteline delimits Haml Comment
         cblock4d


  &lt;div&gt;
    &lt;p&gt;cblock1&lt;/p&gt;
    &lt;p&gt;
      cblock2a

      cblock2b
      cblock2c
    &lt;/p&gt;

    &lt;p&gt;cblock3&lt;/p&gt;

    &lt;p&gt;
      cblock4inline
      cblock4a
      cblock4d
    &lt;/p&gt;
  &lt;/div&gt;
</code></pre>

<h2>Heads and Their Content Models</h2>

<p>This section contains additional details and comments for Haml with 
WSE extensions. Refer to the RSpec and Test implementations for 
further details and examples.</p>

<h3>General</h3>

<p><code>%tag Inline Content</code>, <code>%tag\nNested Content</code>, and 
<code>%tag Inline Content\nNested Content</code> (Mixed Content) make up the
bulk of Haml that embellish plaintext in the HamlSource. The Offside
Rule and Orderly Indentation Rule (OIR) (default:loose) are both observed. </p>

<p>Haml Comments may appear throughout the <code>%tag</code> ContentBlock. Haml Comments
observe Offsides, but in a change under WSE, do not enforce OIR. This latter
change in WSE makes it possible for an author to comment-out blocks of Haml 
text (or even embedded literal Html) without having to change the indentation
to satisfy OIR. See the Haml Comments notes regarding the extent of the 
ContentBlock for Haml Comments falling onside of a ContentBlock for another
Haml Element.</p>

<h3>Haml Comments</h3>

<p>Note: These details do not refer to Haml Comments used as processing
instructions (presently: encoding 'coding' ) at the beginning of the 
HamlSource.</p>

<p>Legacy Haml permitted Mixed Content for Haml Comments, so: 
<code>-# Inline Comment</code>, <code>-#\nNested Comment</code>, and 
<code>-# Inline Comment\nNested Comment</code> (Mixed Content). </p>

<p>In legacy Haml the Haml Comment ContentBlock enforced OIR: the ContentBlock
ended upon Offside.</p>

<p>Under WSE, Haml Comments do not enforce OIR. Haml Comments observe a 
modified Offside Rule: regardless of the IndentStep, the BlockLeftMargin 
is established at the minimum Indentation: the Indentation of the 
Haml Comment lexeme, plus 1:</p>

<pre><code>
  Code 9.2-01

  0123
  -# Haml Comment Inline
   ^
   | BlockLeftMargin, the reference for the Offside Rule in Haml Comments

  0123
  -# 
     Haml Comment Nested
   ^
   | BlockLeftMargin, the reference for the Offside Rule in Haml Comments
     (Requires WSE Haml's OIR rules, unless under legacy Haml the file is 
      globally using a 3-space IndentStep.) 
</code></pre>

<p>In consequence, for TextLines in Haml Comments the indentation
may increase and decrease arbitrarily ... provided they stay 'onside.'
This offers more flexibility for commenting out code without changing
it's indentation, making it easy to re-activate such code.</p>

<p>As mentioned above, Haml Comments (within the HamlSource body) are 
transparent to all other Haml processing. As such, an author could be 
forgiven for thinking that a Haml Comment couldn't alter the semantics 
of the interpreted Haml, that the Haml Comment should be absent from the 
abstract tree. </p>

<p>But there is one surprise: in legacy Haml a Haml Comment <em>can</em> delimit
a Multiline block, and therefore can break into two a larger Multiline block.
This was suggested in the forums as a work-around for authors who were 
surprised that a Whiteline couldn't perform that feat. So, even though it is 
<strong>whack</strong>, and in WSE a Whiteline can now also perform that feat, WSE 
extensions will also, for backward compatibility, support Haml Comment in 
that role. See details elsewhere in these Implementation Notes, and in 
the RSpec test files.</p>

<p>Concerning syntax, Haml lexemes are usually separated from their operands
by whitespace. The Haml Comment lexeme "-#" need not be. The following
are two legal (in legacy, and supported in WSE) Haml Comments:</p>

<pre><code>
  Code 9.2-02

  -# Text comment
  -#Text comment
</code></pre>

<p>In legacy Haml, Mixed Content is prohibited for other operators: you get
Inline Content or Nested Content, but not the combination. Having Mixed 
Content as a normal content model throughout legacy Haml would have enhanced
author expression and control over semantics and output, and enhances 
maintenance. Permitting Mixed Content for Haml Comments, however, gave 
<em>general content</em>-scope semantics for a meta operator. As it has
turned out, it was an unfortunate design choice.</p>

<p>WSE Haml, to the contrary, allows Mixed Content in all but a few cases 
(e.g., doctype). In addition, WSE Haml widely permits OIR:loose ... in 
which the ContentBlock need not follow strict indentation, provided it 
remains 'onside'.</p>

<p>Ideally, the entirety of the WSE extensions would present no conflict
with Haml Comments, for both general and specific reasons. The general 
reason: keeping the rules of HamlSource syntax and generated HtmlOutput 
simple, while enabling forms authors are likely to use. The more specific 
reason: when commenting-out existing Haml code, an author shouldn't have
to restructure the code (changing all the indenting from a compliance with
OIR:loose to that of OIR:strict), complicating what is still communicated 
in the source, and any later reversal.</p>

<p>The two do come into conflict, however: a Haml Comment with nesting
Textlines could be difficult to separate from the content of an immediately 
enclosing Element having Mixed or Nested Content. This was already a
challenge for authors in legacy Haml, but with OIR:loose the challenge has 
grown under WSE. </p>

<p>Consider the following Haml, perhaps program-generated. We have <code>%scat</code> 
categories, each with three children (oir:loose).</p>

<pre><code>
  Code 9.2-03

  %esku
    %skulist
      %scat Lights
                 %sid 20301
               %sname Spot2
              %sdescr Follow spotlight
      %scat Sound
                 %sid 20304
               %sname Amplifier
              %sdescr 60watt reverb
</code></pre>

<p>A Haml Comment could fit in that structure in many places, without 
ambiguity and without changes to the indentation of the HamlSource.</p>

<p>Here's one fit that's a bit difficult (which you can bet would show 
up on SO) where an Inline <em>or</em> Nested Content Model for Haml Comments 
would have been better:</p>

<pre><code>
  Code 9.2-04

  %esku
    %skulist
      %scat Lights
                 %sid 20301
             -#%sname Spot2                # Haml Comment Inline
               %sname Spot3                # Haml Comment Nested
              %sdescr Follow spotlight     # Haml Comment Nested
      %scat Sound
                 %sid 20304
               %sname Amplifier
              %sdescr 60watt reverb
</code></pre>

<p>If Haml Comments were just either-or Inline or Nested this Inline case would 
work fine: only that line would have been taken up in the Haml Comment. 
But the Nested-only case could not have meet all the criteria for this 
particular XML author's obsession. The solution under WSE is similar to what
the author would have done if trying a Nested-only approach: in WSE you have
to add a line, a Whiteline. </p>

<pre><code>
  Code 9.2-05

  %esku
    %skulist
      %scat Lights
                 %sid 20301
             -#%sname Spot2                # Haml Comment Inline

               %sname Spot3
              %sdescr Follow spotlight
      %scat Sound
                 %sid 20304
               %sname Amplifier
              %sdescr 60watt reverb
</code></pre>

<p>TODO: How disruptive would it be to <em>disallow</em> the Legacy Haml support
for Mixed Content for Haml Comments?</p>

<p>This approach allows authors much more freedom in the placement of their
leading "-#" and insertion of any commentary, while preserving the 
indentation of their original text ... at a small incompatibility with 
some legacy Haml. </p>

<p>To recap: Under WSE, the Haml Comment supports the legacy Content Models of
Inline, Nested, and Mixed Content. The extent of its ContentBlock is the 
first of: Offsides (the BLM is at the Head indentation + 1), or a Whiteline.</p>

<p>Finally, Haml Comments are <strong>not</strong> recognized in HereDoc ContentBlocks:
the line is taken as just another Line to copy through.</p>

<h3>Html Comments</h3>

<p>Html Comments are supported in these forms: <code>/ Inline Comment</code>, 
<code>/\nNested Comment</code>, and <code>/ Inline Comment\nNested Comment</code> 
(Mixed Content).</p>

<p>Html Comments may appear throughout a <code>%tag</code> ContentBlock.</p>

<p>Html Comments do not observe OIR. Html Comments follow a modified 
Offside Rule: regardless of the IndentStep, the BlockLeftMargin is 
established at the minimum Indentation: the Indentation of the 
Html Comment lexeme, plus 1:</p>

<pre><code>
  Code 9.3-01

  0123
  / Html Comment Inline
   ^
   | BlockLeftMargin, the reference for the Offside Rule
</code></pre>

<p>A space is not required between the initial "/" and the content block.</p>

<p>WSE Haml introduces two additional Html Comment facilities to free authors 
of the repetitive weed-pulling of changing Haml Comment annotations, yet
still generate HTML that's not just pretty, but also well-formed. The first 
facility concerns nesting of the "/ " within another "/ " Element. Instead 
of creating a second, (improperly) enclosed, HTML comment element, WSE Haml 
defangs this surprise: the contained "/ " is replayed literally, as part of 
the enclosing Html comment text. </p>

<p>The second facility concerns another scenario where authors think they 
are writing/maintaining Haml, which is mostly plaintext with a sprinkling 
of Haml lexemes and Ruby/Perl, but most certainly is <em>not</em> Html. This 
(and the fact that legacy Haml supports interpolation inside the Haml 
Html Comment ContentBlock, as does WSE Haml) easily leads to the case of 
two hyphens--a common feature of plaintext--appearing inside an 
HTML-compliant comment, such as when a Haml author prefixes what is 
otherwise plaintext with the Haml Comment lexeme. (A simplified variation
of this case was raised in GitHub Issue 88 and was met with one of those
"don't do that" responses mentioned in the introduction of these Notes.)
WSE Haml will recognize and adjust for the cases that typically arise
(transformed in the order of priority shown):</p>

<pre><code>  Within Haml Comment ContentBlock (WSE Haml)
  HamlSource                        WSE Haml HtmlOutput
  (After Interpolation)
  ---------------------             ---------------------
  1. /--+&gt;/                         --&gt;&lt;!--
  2. /&lt;!--+/                        --&gt;&lt;!--
  3. /-(-+)/                        '-' + ' ' * $1.length 
</code></pre>

Selected cases:

<pre><code>
  Code 9.3-02

  .zork
    %p para1
    / plaintext html comment
    %p para2
    / comment with embedded --> html comment endtag
    <p>para3</p>
    / comment with embedded <!-- html comment starttag
    <p>para4</p>
    / comment with embedded --- serial hyphens

  &lt;div class='zork'&gt;
    &lt;p&gt;para1&lt;/p&gt;
    &lt;!-- plaintext html comment --&gt;
    &lt;p&gt;para2&lt;/p&gt;
    &lt;!-- comment with embedded --&gt;&lt;!-- html comment endtag --&gt;
    &lt;p&gt;para3&lt;/p&gt;
    &lt;!-- comment with embedded --&gt;&lt;!-- html comment starttag --&gt;
    &lt;p&gt;para4&lt;/p&gt;
    &lt;!-- comment with embedded -   serial hyphens --&gt;
  &lt;/div&gt;
</code></pre>

<h3>Multiline Text</h3>

<p>The Multiline syntax provides authors a simple form for specifying
over several HamlSource lines a single-line ContentBlock. </p>

<p>The syntax is 'infix', with a " |" (space-pipe) as the last non-whitespace 
on each line. For clarity, the last line must also carry the " |". </p>

<p>The OIR is <strong>not</strong> enforced; the Offside Rule does <strong>not</strong> apply.</p>

<p>Initial whitespace is removed. The trailing whitespace (before the
" |" space-pipe lexeme), the newline, and the leading whitespace of
the next line is consolidated (into a single space). Whitespace around
any interpolated newlines receives the same treatment.</p>

<p>Because Multiline provides an author an alternative method of providing 
HamlSource, interpolated newlines <em>do not</em> break the Multiline. This 
is a change from Legacy Haml, which exhibits an inexplicable reversal 
in processing, in that surface syntax is interpreted <strong>after</strong> content 
semantics. What happens in WSE Haml: The lexer builds an AST having 
the Parent Element's Head as a node, having a Nested ContentBlock, 
and having as its child a node for the Multiline syntactic form. The 
lexer strips the ContentBlock of Multiline Elements of the Multiline 
Lexemes, leaving for the parser (subsequently) to process the lines 
and then finally combine the lines according to Multiline <em>semantics</em>.</p>

<p>If the Head of a Textline contains "-#" that line will terminate a 
Multiline Text block (as in legacy Haml), <strong>even if</strong> that line ends with 
the " |" pipe lexeme (a WSE Haml variance to legacy Haml). This idiom 
(of Haml Comment-demarcation of two adjacent Multiline Elements) is 
deprecated: the recommended separator of two adjacent Multiline 
ContentBlocks is the Whiteline.</p>

<p>TODO: It would be better to undo this blooper in legacy Haml syntax, 
to thereby allow an author to easily remove a line from a Multiline Text 
block by Haml-Commenting it, while not breaking the overall Multiline. 
But would the breakage in legacy Haml code be too great?</p>

<h3>HereDoc</h3>

<p>As presented above, HereDoc is a WSE Haml Content Model, which provides
the entire ContentBlock to its Element. It is an alternative to Inline
Content, Nested Content, or Mixed Content.</p>

<p>Within HereDoc Content, the Orderly Indentation Rule and BlockLeftMargin
effects (including Offside) are suspended. </p>

<p>The HereDoc ContentBlock is inert with respect to Haml tags, =expressions, 
-code, and so on. It is processed for interpolation (as if a double-quoted 
string).</p>

<pre><code>
  Code 9.5-01

  %body
    %dir
      %dir
        %p&lt;&lt;DOC
       HereDoc
  -# #{var1}
  DOC

  &lt;body&gt;
    &lt;dir&gt;
      &lt;dir&gt;
        &lt;p&gt;
       HereDoc 
  -# variable1
        &lt;/p&gt;
      &lt;/dir&gt;
    &lt;/dir&gt;
  &lt;/body&gt;
</code></pre>

<p>Notice: 
*   The HereDoc is replayed without adjusting indentation, and
*   Interpolation is supported, and
*   The Haml Comment syntax is ignored -- it is just plaintext</p>

<p>An extended syntax is provided, permitting indentation of the terminal 
delimiter:</p>

<pre><code>
  Code 9.5-02

  %body
    %dir
      %dir
        %p&lt;&lt;-DOC
       HereDoc
  -# #{var1}
        DOC
</code></pre>

<p>WSE Haml's HereDoc syntax does not admit the single-quote extended syntax.</p>

<p>TODO: Perhaps it should? For what use cases?</p>

<p>When mixed with other components of Head syntax, the HereDoc lexeme falls
last:</p>

<pre><code>
  Code 9.5-03

  %p{:a =&gt; 'b',
     :y =&gt; 'z'}&lt;&lt;DOC
  HereDoc Para
  DOC
</code></pre>

<p>Here with the trim_out lexeme:</p>

<pre><code>
  Code 9.5-04

  %p&gt;&lt;&lt;DOC
  HereDoc Para
  DOC
</code></pre>

<p>A Textline following the Line containing the HereDoc Terminator is,
either the sibling to the Element to which the HereDoc provides its
content (when having an Indentation equal to or greater than the 
Element's Head), or is a cousin to that Element (when having a lesser
Indentation than the Element's Head). Notice that the relevant
Indentation is with respect to the Element's Head not the HereDoc 
Terminator.</p>

<pre><code>
  Code 9.5-05

  As a sibling:

  %body
    %dir
      %dir
        %p#n1&lt;&lt;-DOC
       HereDoc Para
       DOC
          %p#n2 para2

  &lt;body&gt;
    &lt;dir&gt;
      &lt;dir&gt;
        &lt;p id='n1'&gt;
       HereDoc Para
        &lt;/p&gt;
        &lt;p id='n2'&gt;para2&lt;/p&gt;
      &lt;/dir&gt;
    &lt;/dir&gt;
  &lt;/body&gt;
</code></pre>

<p>Undented with respect to the Element's Head, so as a child of
a common ancestor:</p>

<pre><code>
  Code 9.5-06

  %body
    %dir
      %dir#d1
        %p#n1&lt;&lt;-DOC
       HereDoc Para
    DOC
      %p#n2 para2

  &lt;body&gt;
    &lt;dir&gt;
      &lt;dir id='d1'&gt;
        &lt;p id='n1'&gt;
       HereDoc Para
        &lt;/p&gt;
      &lt;/dir&gt;
      &lt;p id='n2'&gt;para2&lt;/p&gt;
    &lt;/dir&gt;
  &lt;/body&gt;
</code></pre>

<p>Whitespace Removal lexemes may be used in their usual position, as the
last lexeme of the Head, before the HereDoc token.</p>

<p>The following establishes conflicting modes regarding the Content Model,
and are therefore prohibited, halting Haml processing with an exception
(because to simply warn or otherwise continue could lead to unnoticed 
missing content in the HtmlOutput):</p>

<pre><code>
  Code 9.5-07

  %img&lt;&lt;DOC        # %img is included in autoclose; no content
  HereDoc
  DOC
</code></pre>

<p>Inline autoclose lexeme:</p>

<code><pre>
  Code 9.5-08

  %sku/&lt;&lt;DOC       # Make %sku autoclose, so no content
  HereDoc
  DOC
</code></pre>

<p>As noted above, the HereDoc is a method for providing an Element's
ContentBlock: where an Element supports HereDocs, that Element's 
resulting ContentBlock (after the HereDoc interpretation, including 
interpolation) is valid for any type of Content Model (Inline, Nested, 
or Mixed). If, for example, the Element's Head is listed in 
<code>option:preserve</code>, the standard preserve transformations will be 
eventually be applied. </p>

<p>TODO: Perhaps plaintext or interpolated text might follow the HereDoc lexeme,
after the fashion of <code>helper:succeed</code>? The following three examples explore
this possibility (and would give better results with "&lt;" and ">"), although 
there doesn't seem a particularly strong use case, and perhaps there's 
another better use for that slot.</p>

<p>TODO: Candidate capability for content following the HereDoc token</p>

<pre><code>
  Code 9.5-09

  %span.red&lt;&lt;DOC.
  HereDoc Para
  DOC

  &lt;spam class='red'&gt;
  HereDoc Para
  &lt;/p&gt;.
</code></pre>

<p>TODO: Candidate capability for content following the HereDoc token</p>

<pre><code>
  Code 9.5-10

  *
  %span.ital&lt;&lt;-DOC *
            HereDoc Para
       DOC

  *
  &lt;span class='ital'&gt;
            HereDoc Para
  &lt;/span&gt; *
</code></pre>

<p>TODO: Candidate capability for content following the HereDoc token</p>

<pre><code>
  Code 9.5-11

  - punct = '...'
  %span &lt;&lt;DOC#{punct}
  HereDoc Para
  DOC

  &lt;span&gt;
  HereDoc Para
  &lt;/span&gt;...
</code></pre>

<h3>Preserve (<code>option:preserve</code>)</h3>

<p>By listing a tag in <code>option:preserve</code> the author indicates that special 
treatment should be applied to preserve some aspects of the ContentBlock's 
whitespace.</p>

<p>This special treatment occurs in two cases; both cases apply only when the
Element is determined to have (only) Inline Content. Nested Content will 
not prompt the special treatment; this is unchanged in WSE Haml,
as a change would affect many occurrences of a <em>preserve</em> Head.</p>

<p>(TODO: If, instead, a case were made to change <code>option:preserve</code> to 
support Nested content, such a change would be compatible with WSE Haml. 
This would bring many of the benefits that <code>option:preformatted</code> brings 
to the listed tags, yet preformatted would still be beneficial as it 
offers other mechanisms--OIR:loose, replay of whitespace, and newlines 
without special entities.)</p>

<p>If an Element's Head is an expression with <code>find_and_preserve</code> or a 
Tilde-expression (<code>~ expr</code>), then the special treatment is applied to a
segment of the Element's Inline ContentBlock: within the Inline content, 
newlines occurring between the HTML start tag and HTML end tag of a 
<code>option:preserve</code>-listed tag will be transformed (with special handling
of any trailing newlines). The other newlines are not transformed.</p>

<p>In the second case, if an Element's Head is one of the tags listed in
<code>option:preserve</code>, then the special treatment (transformation of newlines) 
is applied to the entire Inline content. This includes the content provided 
via a HereDoc ContentBlock.</p>

<p>In a variant of this second case, if an Element's Head <strong>is</strong> a member of
<code>option:preserve</code>, and instead of an Inline ContentBlock is determined to
have a Nested (only) ContentBlock, no special treatment is applied: the 
result is as if the tag were <strong>not listed</strong> in <code>option:preserve</code>.</p>

<p>Take careful note of an important interaction between an <code>option:preserve</code>
tag and nesting content. In legacy Haml, Mixed Content was prohibited, thus
the absence of Inline Content, and the presence of a Nested Content 
ContentBlock signals that the tag should be treated as a normal tag (no 
special treatment). WSE Haml, however, introduces Mixed Content ... which 
appears like a combination of Inline and Nested Content. This would be an 
error in legacy Haml, and it remains, for <code>option:preserve</code> tags, an error
in WSE Haml. If Mixed Content is desired/necessary, perhaps the 
<code>option:preformatted</code> treatment would be suitable.</p>

<p>A tag's membership in <code>option:preformatted</code> takes precedence over its
membership in <code>option:preserve</code>. In WSE Haml tags <code>%pre</code> and 
<code>%textarea</code> are by default removed from <code>option:preserve</code> and listed in 
<code>option:preformatted</code>. Authors will also list in <code>option:preformatted</code> 
the tags for which they've assigned CSS-style <code>white-space:pre</code>-like 
mechanics (or will have such tags' ContentBlock supplied via <code>HereDoc</code> 
or <code>filter:preformatted</code>).</p>

<p>One difference between the two treatments (preserve, versus preformatted)
is the surface structure of the HtmlOutput: the placement of element
content with respect to the Html start tag and the Html end tag. Preserve 
mechanics will run the element's content <em>inline</em> with the start tag and 
end tag (including when supplying a <code>filter:preserve</code> content block);
Preformatted mechanics will run the element's content <em>nested</em>.</p>

<pre><code>
  Code 9.6-01

  :preserve =&gt; ['ptag']

  .wspcpre
  %snap
    %ptag= "Bar\nBaz"
  %crak
    %ptag #{strvar}
  %pahp
    %ptag
      :preserve
            def fact(n)  
              (1..n).reduce(1, :*)  
            end  

  &lt;div class='wspcpre'&gt;
    &lt;snap&gt;
      &lt;ptag&gt;Bar&amp;#x000A;Baz&lt;/ptag&gt;
    &lt;/snap&gt;
    &lt;crak&gt;
      &lt;ptag&gt;toto&amp;#x000A;tutu&lt;/ptag&gt;
    &lt;/crak&gt;
    &lt;pahp&gt;
      &lt;ptag&gt;  def fact(n)  &amp;#x000A;    (1..n).reduce(1, :*)  &amp;#x000A;  end&lt;/ptag&gt;
    &lt;/pahp&gt;
  &lt;/div&gt;
</code></pre>

<p>Notice: The OutputIndent for filter:preserve is 2 spaces--that is the
difference after the IndentStep is removed (legacy Haml file-global,
or WSE Haml OIR-calculated). Here, in legacy Haml, the IndentStep is 2,
so the remainder is 2, and that Initial Whitespace is replayed.</p>

<pre><code>
  Code 9.6-02

  :preformatted = ['vtag']

  .wspcpre
    %snap
      %vtag= "Bar\nBaz"
    %crak
      %vtag #{strvar}
    %pahp
      %vtag
        :preformatted
            def fact(n)  
              (1..n).reduce(1, :*)  
            end  
    %vtag&lt;&lt;ASCII
  o           .'`/
      '      /  (
    O    .-'` ` `'-._      .')
       _/ (o)        '.  .' /
       )       )))     &gt;&lt;  &lt;
       `\  |_\      _.'  '. \
         `-._  _ .-'       `.)
     jgs     `\__\
  ASCII


  &lt;div class='wspcpre'&gt;
    &lt;snap&gt;
      &lt;vtag&gt;
  Bar
  Baz
      &lt;/vtag&gt;
    &lt;/snap&gt;
    &lt;crak&gt;
      &lt;vtag&gt;
  toto
  tutu
      &lt;/vtag&gt;
    &lt;/crak&gt;
    &lt;pahp&gt;
      &lt;vtag&gt;
        def fact(n)  
          (1..n).reduce(1, :*)  
        end  
      &lt;/vtag&gt;
    &lt;/pahp&gt;
    &lt;vtag&gt;
  o           .'`/
      '      /  (
    O    .-'` ` `'-._      .')
       _/ (o)        '.  .' /
       )       )))     &gt;&lt;  &lt;
       `\  |_\      _.'  '. \
         `-._  _ .-'       `.)
     jgs     `\__\
    &lt;/vtag&gt;
  &lt;/div&gt;
</code></pre>

<p>Notice: Under WSE Haml, filter:preformatted delivers a ContentBlock 
with the BLM of its ContentBlock aligned with the indentation of the 
:preformatted Head.</p>

<p>The particular newline transformation associated with preserve is further 
documented above, below in "find_and_preserve", and in 
the RSpec and Test suites.</p>

<h3>Helper: find_and_preserve</h3>

<p>The underlying <em>preserve</em> mechanics are those of <code>option:preserve</code>.
Please review that section and the sections preserving whitespace, and
normalizing whitespace in HtmlOutput.</p>

<p>Here is an example from the Haml Reference (for "~ expr"), and variants:</p>

<pre><code>
  Code 9.7-01

  options: preserve =&gt; 'pre', html_escape =&gt; false
  %zot
    = find_and_preserve("Foo\n&lt;pre&gt;Bar\nBaz&lt;/pre&gt;")
    = find_and_preserve("Foo\n%Bar\nBaz")
    = find_and_preserve("Foo\n&lt;xre&gt;Bar\nBaz&lt;/xre&gt;")
</code></pre>

<p>Legacy Haml gives this result, which since it lacks Initial or 
Trailing Whitespace, and trailing newlines, is the same in WSE Haml:</p>

<pre><code>
  &lt;zot&gt;
    Foo\n  &lt;pre&gt;Bar&amp;#x000A;Baz&lt;/pre&gt;
    Foo\n  %Bar\n  Baz
    Foo\n  &lt;xre&gt;Bar\n    Baz&lt;/xre&gt;
  &lt;/zot&gt;
</code></pre>

<p>If escaped HtmlOutput is requested, here's the result--with the WSE Haml
fix for producing HtmlOutput that's escaped, which prevents escaping an 
already-escaped entity:</p>

<pre><code>
  Code9.7-02

  option: preserve =&gt; 'pre', html_escape =&gt; true

  &lt;zot&gt;
    Foo\n  &amp;lt;pre&amp;gt;Bar&amp;#x000A;Baz&amp;lt;/pre&amp;gt;
    Foo\n  %Bar\n  Baz
    Foo\n  &lt;xre&gt;Bar\n    Baz&lt;/xre&gt;
  &lt;/zot&gt;
</code></pre>

<h3>Preserve Expression Head: "~ expr"</h3>

<p>The whitespace mechanics are the same as for <code>helper:find_and_preserve</code>.</p>

<p>Note that WSE Haml will produce a different result from legacy Haml in the 
case when the author requests escaped HtmlOutput, correcting a difference
in legacy Haml between find_and_preserve and the tilde operator:</p>

<pre><code>
  Code 9.8-01

  options: preserve =&gt; 'pre', html_escape =&gt; true
  %zot
    ~ "Foo\n&lt;pre&gt;Bar\nBaz&lt;/pre&gt;"

  The buggy legacy Haml result:

  &lt;zot&gt;
    Foo\n  &amp;lt;pre&amp;gt;Bar\n  Baz\n&amp;lt;/pre&amp;gt;
  &lt;/zot&gt;

  In WSE Haml the 'interior' newline is transformed and escaped, 
  producing the same result as for (the WSE-adjusted) 
  find_and_preserve, plus no whitespace normalization is performed
  (i.e., no added whitespace):

  &lt;zot&gt;
    Foo\n  &amp;lt;pre&amp;gt;Bar&amp;#x000A;Baz&amp;lt;/pre&amp;gt;
  &lt;/zot&gt;
</code></pre>

<h3>Filter: preserve</h3>

<p>The whitespace mechanics are the same as for the <code>option:preserve</code>.</p>

<h3>Helper: preserve</h3>

<p>The whitespace mechanics are the same as for <code>Filter:preserve</code>,
with the exception that Helper:preserve is altered according to
the WSE Haml extensions to produce the idempotent Html escaping.</p>

<h3>Preformatted</h3>

<p>Elements whose Heads are listed in <code>option:preformatted</code> admit
Inline, Nested, and Mixed Content. This option (aka: verbatim tags) 
is new to Haml with WSE Haml.</p>

<p>A <em>preformatted</em> tag observes Offsides, and permits OIR:strict or loose.</p>

<p>A tag appearing in both <code>option:preformatted</code> and <code>option:preserve</code>
is interpreted under <code>option:preformatted</code>.  In WSE Haml, tags <code>%pre</code> 
and <code>%textarea</code> are by default shifted from <code>option:preserve</code> to 
<code>option:preformatted</code>. Authors will also list in <code>option:preformatted</code> 
the tags for which they've assigned CSS-style <code>white-space:pre</code>-like 
mechanics (or will have such tags' ContentBlock supplied via <code>HereDoc</code> 
or <code>filter:preformatted</code>).</p>

<p>The change in Content Model is unlikely to introduce problems in legacy Haml 
code when subjected to WSE Haml <code>option:preformatted</code> semantics--under 
legacy Haml the <code>option:preserve</code> code could not have (could not appear to 
have) Mixed Content (it could have Inline--which would get the preserve 
transforms, or Nested--which would be treated as if a non-preserve tag). 
Under preformatted, the Inline Content may appear slightly different in the 
HtmlOutput, but that will be not the result of interpretation under a 
different Content Model, but the result of small differences from the 
<code>option:preserve</code> implementation.</p>

<h3><code>option:ugly</code></h3>

<p>The option <code>option:ugly</code> overrides all whitespace mechanics. Except
for HamlSource side-effects, WSE Haml leaves this unchanged.</p>

<h3><code>option:autoclose</code></h3>

<p>Elements whose Heads are listed in <code>option:autoclose</code> are subject to
various whitespace consolidation and removal. Except for HamlSource
side-effects, WSE Haml leaves this unchanged.</p>

<h3>Included Html</h3>

<p>The Haml References states:</p>

<pre><code>  Note that HTML tags are passed through unmodified as well.
  If you have some HTML you don't want to convert to Haml,
  of if your converting a file line-by-line, you can just
  included it as-is.
</code></pre>

<p>Well, not quite: Haml is not <em>HtmlSource</em> aware. Html-tagged text is treated
simply as plaintext, which is, problematically, subject to the rules of 
ordinary Nesting Content. Inserting a single clause of HTML is fine. 
Because the legacy Haml processing rules for plaintext prohibit indentation,
however, a longer HtmlSource text must adhere to a single left margin.
This is, however, unlikely for ordinary Html.</p>

<p>The solution is, it is thought, to feed it as a single inline to an 
Html-aware '= expr' processing block, or <em>filter</em>.</p>

<p>Well, neither quite works. WSE Haml offers two solutions: Elements with a
Head in <code>option:preformatted</code>, or through HereDoc.</p>

<h3>Whitespace Removal trim_out '<code>&gt;</code>' and trim_in '<code>&lt;</code>'</h3>

<p>These lexemes do, naturally, alter whitespace--Initial, Leading, and
Trailing Whitespace. Apart from a minor bugfix, WSE Haml does not alter
the mechanics for these operators.</p>

<p>One side-effect of WSE Haml concerns Mixed Content, and the generation
of the related HtmlOutput. Recall that with Mixed Content, WSE Haml will
honor author decisions about Inline content--copying the Inline Content 
onto the same HtmlOutput line as the Head, which for the tag-start end
produces the same effect as the <em>trim</em>in_ operator.</p>

<pre><code>
  Code 9.15-01

  %bac
    %p Foo                     # WSE Haml Mixed Content
      Bar
      Baz

  &lt;bac&gt;
    &lt;p&gt;Foo                     # WSE Haml runs Inline tight
      Bar                      # Same as Legacy indentation
      Baz
  &lt;/bac&gt;


  %saus
    %p= "Thud\nGrunt\nGorp"    # Provides non-preserve tag nested content

  &lt;saus&gt;
    &lt;p&gt;Thud                    # WSE Haml runs this tight
      Grunt                    # Indented as if ordinary nested content
      Gorp
    &lt;/p&gt;
  &lt;/saus&gt;
</code></pre>

<p>Trim_in with WSE Haml:</p>

<pre><code>
  Code 9.15-02

  %eggs
    %div
      %p&lt; Foo
        Bar
        Baz
    %p para1

  &lt;eggs&gt;
    &lt;div&gt;
      &lt;p&gt;Foo
        Bar
        Baz&lt;/p&gt;
    &lt;/div&gt;
    &lt;p&gt;para1&lt;/p&gt;
  &lt;/eggs&gt;


  %spam
    %div
      %p&lt;= "  Foo\nBar\nBaz  "
    %p para2

  &lt;spam&gt;
    &lt;div&gt;
      &lt;p&gt;  Foo                  # Runs tight, replaying Leading Whitespace
        Bar
        Baz  &lt;/p&gt;               # Trim_in pulls up end tag, after Whitespace
    &lt;/div&gt;
  &lt;/spam&gt;
</code></pre>

<p>Note, that WSE Haml corrects a nit-ish bug with <em>trim</em>out_, where the Html
endtags are not symmetrically aligned with the starttags. The following
example shows how WSE Html will render the Html.</p>

<pre><code>
  Code 9.15-03

  %p
  %out
    %div&gt;
      %in
        Foo!

  &lt;p&gt;
    &lt;out&gt;&lt;div&gt;
        &lt;in&gt;
          Foo!
        &lt;/in&gt;
    &lt;/div&gt;&lt;/out&gt;               # WSE Haml aligns symmetrically with start
  &lt;/p&gt;
</code></pre>

<h3>New WSE Haml Whitespace-related Operators and Aliases</h3>

<p>Related to the above-mentioned whitespace frames, WSE implements two new
whitespace-related operators, and to help clarify the targeted whitespace
frame, a small group of aliases to legacy operators.</p>

<p>These were born of early experience with Haml ... where one of the authors 
(Ragouzis) found a few operator names a bit ambiguous. In one case, to 
disambiguate the locus of the haml_indent operator, it required comparison of
<code>haml_indent.length</code> for Inline versus Nested Content, confirming it refers
to the <strong>Html</strong> OutputIndent. </p>

<p>The new operators:</p>

<pre><code>  Operator or Control           Locus of Production or Side-Effect
  ---------------------------   -----------------------------------
  html_tabs          Helper     HtmlOutput
                                Yields the count of 'tabs' in the current
                                OutputIndent.

  html_tabstring     Helper     HtmlOutput
                                Yields the string used for a single 'tab'
                                of the OutputIndent 
</code></pre>

<p>The following table lists the new operators and newly-assigned aliases, 
indicating the operator's locus of production or side-effect (HamlSource, 
or HtmlOutput).</p>

<pre><code>  Locus of Production or Side-Effect

  HamlSource                |  HtmlOutput
  ---------------           |  ------------------
                            |  helper:html_indent     (WSE alias for haml_indent)
                            |
                            |  helper:capture_html    (WSE alias for capture_haml)
                            |  helper:html_concat     (WSE alias for haml_concat)
                            |  helper:html_tag        (WSE alias for haml_tag)

  Related:
                            |  helper:tab_up          (unchanged)
                            |  helper:tab_down        (unchanged)
                            |  helper:with_tabs       (unchanged)
                            |  helper:html_tabs       (WSE proposed function)
                            |  helper:html_tabstring  (WSE proposed function)

                            |  helper:surround        (unchanged)
                            |  helper:precede         (unchanged)
                            |  helper:succeed         (unchanged)

                            |  helper: html_escape    (now Doctype-proper escape_once)
                            |  helper: escape_once    (unchanged)

                            |  option: escape_html    (now Doctype-proper, idempotent)
                            |  operator: &amp;=           (now Doctype-proper, idempotent)
                            |  operator: &amp;            (now Doctype-proper, idempotent)

                            |  filter: escapehtml     (legacy filter 'escaped') *1

                            |  filter: preformatted   (WSE-active verbatim)
  filter: preserve *2       |
  helper: find_and_preserve |

                            |  helper: list_of        (unchanged)
                            |  helper: to_s           (unchanged)
                            |  helper: html_attrs     (unchanged)



  Implementation-oriented (mostly), changes might be helpful/useful:

  helper: non_haml
  helper: is_haml
  helper: block_is_haml
  helper: merge_name_and_attributes

  instance: haml_buffer     # perhaps: html_buffer


  helper: haml_bind_proc    # perhaps: html_bind_proc (with related local var changes)
  helper: with_haml_buffer  # perhaps: with_html_buffer
</code></pre>

<p>Notes:</p>

<ol>
<li><p>The change from <code>filter:escaped</code> to <code>filter:escapehtml</code> better aligns
  the filter's name with other filter names (which for the most part 
  identify a characteristic of the input, or the operation). 
  <code>filter:escape_html</code> might be better; aligning similar options and
  helpers might be beneficial.</p></li>
<li><p>It seems more informative to note that these three facilities 
  <code>filter:preserve</code>, <code>helper:find_and_preserve</code> (and it's client
  <code>~expr</code>), and the related (wrt newline transform) <code>option:preserve</code>
  work as two-part operators. The operator performs its transform on 
  HamlSource. The result is then subject to any further Haml processing, 
  and that result becomes HtmlOutput. That the first operation <br />
  converts the newlines directly to an Html Entity is just an 
  implementer's convenience. For further discussion, see "The Newline
  Transform -- Implementation Internals" at the end of this document.</p></li>
</ol>

<h3>Models for Html Escape</h3>

<p>An author may request HtmlOutput with some portion of the Html escaped. 
To deliver HtmlOutput with escaped Html, WSE Haml performs
Option/DocType-sensitive escaping.</p>

<p>As mentioned above, there are two effects tempered by Options and the 
DocType:</p>

<ul>
<li><p>Special character escaping</p>

<p>Escaping of the apostrophe is limited to documents using an effective 
XML-related DocType or escaping option. </p></li>
<li><p>Idempotent Escaping (the Ampersand)</p>

<p>Specifically: Escaping <code>&amp;amp;</code> gives you <code>&amp;amp;</code>. This change applies 
across <em>all</em> Haml operators, including an operator such as the Tilde 
expression <code>~ expr</code> and helper functions such as <code>helper:capture_html</code>,
operating individually or in composition.</p></li>
</ul>

<p>The following table summarizes the interaction between <code>option:html</code>
and select DocTypes, and the respective output format:</p>

<pre><code>               FORMAT:OPTION:  HTML4|5       DEFAULT(xhtml)      XHTML
                   -------------------       ----------------    -----
  DOCTYPE  !!!              html401t|5       xhtml 1.0 trans      =
           !!! 5            html401t|5       html5                =
           !!! 1.1          html401t|5       xhtml 1.1            =
           !!! Basic        html401t|5       xhtml b 1.1          =
           !!! Strict       html401|5        xhtml 1.0 s          =
           !!! XML          none|none        xmlencode(only)      =
           none             none             none                 =
</code></pre>

<p>To be clear about conflicting configuration, the rule is:</p>

<pre><code>  1. If you specify option:format=&gt;html4:  you get html rules, 
  2. otherwise:                            you get xml rules (&amp;apos;).

                       FORMAT OPTION
                       DEFAULTED     SPECIFIED
                                     XHTML|5          HTML4
                       ---------     ---------        -----
  DOCTYPE
       none(default)   xml           xml|xml          html
       specified   
         unqual        xml           xml|xml          html
         html5         xml           xml|xml          html
         html4-type    xml           xml|xml          html
         xml-type      xml           xml|xml          html          
</code></pre>

<h2>Glossary</h2>

<ul>
<li><p>BlockLeftMargin (BLM)</p>

<p>The offset indentation that serves as the point of reference for
<em>Offside</em>: the minimum Indentation at which a Textline is considered
to fall within an Element's ContentBlock. In ISWIM, the southeast
quadrant from the Element's Head containing the Elements' definition. </p></li>
<li><p>Element</p>

<p>The fundamental construct of a HamlSource file, made of a Head and
a (possibly null) ContentBlock. A succession enclosed Elements,
with Each ContentBlock containing further Elements describes a 
tree of parents and children.</p></li>
<li><p>Head</p>

<p>A component of an Element. The Head is a (usually prefix) lexeme of 
Haml syntax, such as a Html tag macro (<code>%p</code>) or a Haml meta token 
(such as <code>-#</code> for Haml Comments) or the operator for an expression
(<code>= expr</code>) or code block (<code>- code</code>), for example.</p>

<p>Semantically, the IndentStep is considered part of the head, as it
is part of the description for the extent of the ContentBlock.</p></li>
<li><p>Consolidate (Remove and Replay)</p>

<p>In many cases in WSE Haml, whitespace (linear and vertical) is,
during transformation into HtmlOutput, consolidated: it is reduce 
from many spaces to a single space. By comparison, alternative
transforms are remove and replay.</p></li>
<li><p>ContentBlock</p>

<p>A component of an Element. Depending on the particular Element, the 
ContentBlock may begin in the same line as the Head (Inline Content),
may begin below and indented from the Head (Nested), or both 
(Mixed Content). </p>

<p>WSE Haml is an ISWIM language, meaning that indentation is used such 
that an [Element's] entire definition falls to the "southeast quadrant"
of the [Head]. In WSE Haml this syntax arises from the interplay of
two rules: The Orderly Indentation Rule, and the Offside Rule.</p>

<p>Haml's Multiline Syntax relies on the infix operator (the absence of)
to terminate its ContentBlock.</p>

<p>Haml Comments rely on a Whiteline to terminate its ContentBlock.</p></li>
<li><p>Content Model</p>

<p>Whether the Element's ContentBlock may take Inline Content, Nested Content,
Mixed Content, or HereDoc Content.</p></li>
<li><p>HamlSource</p>

<p>The input into the Haml processor, which in turn generates HtmlOutput.</p></li>
<li><p>HereDoc Content</p>

<p>A type of Content Model for the ContentBlock: the HereDoc provides the
entire ContentBlock of its Element. Neither OIR nor Offside are observed. 
Instead a terminal string is introduced, which, when it appears alone 
on a Line signals that the ContentBlock ended with the prior newline.</p></li>
<li><p>HtmlOutput</p>

<p>The output of the Haml processor, from consuming HamlSource.</p></li>
<li><p>Indentation</p>

<p>A measure: the offset from column 0 of the start of text in a Textline.</p></li>
<li><p>Inline Content</p>

<p>A Content Model where the ContentBlock begins on the line with the
Haml Head.</p></li>
<li><p>IndentStep</p>

<p>The Indentation of a Textline is made up of a series of IndentSteps, a
unit of indentation, the number of which increases for each contained 
ContentBlock.</p>

<p>In legacy Haml, the IndentStep was (typically) two spaces, and once one
IndentStep was lexed, the size of the IndentStep remained fixed throughout
the file. Each child Element's Indentation was one IndentStep deeper.</p>

<p>In WSE Haml, under OIR:strict, the IndentStep must remain fixed within each
immediate Element: it may vary for each child. In addition, Undents must 
unfold (or pop) previous IndentSteps. Under OIR:loose, the default, the 
IndentStep is variable, with the <em>If You See What I Mean</em> of ISWIM 
coming to the fore: Offsides of the Element dominates IndentStep counting.</p>

<p>The IndentStep is predictive of the OutputIndent in the HtmlOutput.</p></li>
<li><p>ISWIM</p>

<p><em>If you See What I Mean</em>, the name Landin proposed for the family of of
languages realizing the described system. Landin described the system 
as having no prescribed physical appearance, but which derive from four
levels of abstraction: applicative expression; abstract tree language;
the logical abstraction; and a physical ISWIM language.</p>

<p>One key feature is the reliance on indentation to demarcate the extent
of content which defines an [Element].</p></li>
<li><p>Line</p>

<p>The general term, for a Textline.</p></li>
<li><p>Mixed Content</p>

<p>A Content Model where the ContentBlock begins on the same line as the
Head, as in Inline Content, and continues, indented, on a following 
Line, as in Nested Content.</p></li>
<li><p>Nested Content</p>

<p>A Content Model where the ContentBlock begins on a following Line, 
perhaps with intervening Whitelines, indented. Unless prohibited
by the specific Head, Nested Content may contain further (Nested)
Elements.</p></li>
<li><p>Orderly Indentation Rule (OIR) loose/strict</p>

<p>The rule that Indentation must increase, and decrease following a prescribed
model. The unit of Indentation is the IndentStep.</p>

<p>In legacy Haml, the IndentStep was (typically) two spaces, and once one
IndentStep was lexed, the size of the IndentStep remained fixed throughout
the file. Each child Element's Indentation was one IndentStep deeper.
Undents must fall at one of these prior Indentation measures, and which
a new Element must be introduced.</p>

<p>In WSE Haml, under OIR:strict, the IndentStep must remain fixed within each
immediate Element: it may vary for each child. In addition, Undents must 
unfold (or pop) previous IndentSteps. This is very much like legacy Haml's
model, but with flexibility in the length of the IndentStep itself.</p>

<p>Under OIR:loose, the default, the IndentStep is variable. This should be
viewed as realizing a the physical realization of a more relaxed abstraction
of <em>If you See What I Mean</em> (ISWIM). Instead, the Offsides Rule becomes
more dominant.</p></li>
<li><p>OutputIndent</p>

<p>The unit of indentation in the HtmlOutput, also known as the OutputTab,
or "tab." By default, each "tab" is two space characters. Lines in 
HtmlOutput are indented in multiples of OutputIndent to reflect the
structure of the </p></li>
<li><p>Preformatted</p>

<p>Refers in WSE Haml to a Content Model for an Element, where the <em>structure</em>
of the HamlSource in the ContentBlock is replayed verbatim to the HtmlOutput,
without newline transforms. (Full Haml processing is performed: interpolation,
expressions, etc.)  Offsides is enforced, but indentation is free (OIR is 
not required within the ContentBlock). In WSE Haml, tags <code>%pre</code> and 
<code>%textarea</code> are shifted from <code>option:preserve</code> to <code>option:preformatted</code>;
authors will also assign those Html tags for which they have assigned CSS
<code>white-space:pre</code>-like mechanics. See details in various parts of the 
document.</p></li>
<li><p>Preserve</p>

<p>Refers in Haml to a transform that converts newlines in HamlSource into the
special entity <code>&amp;#x000A;</code> on HtmlOutput. The side-effect is that the 
related Whitespace is undisturbed. This transform is available through the
<em>preserve</em> filter, through the helper <code>find_and_preserve</code>, for the Head 
tags listed in <code>option:preserve</code>, and for the content of a "~ expr". Both 
Offsides and OIR are observed. See details in various parts of the document.</p></li>
<li><p>Textline (non-Whitelines)</p>

<p>A Line having non-whitespace characters. The Indentation measure is the
offset column index from column 0.</p></li>
<li><p>Undent</p>

<p>Used in reference to a prior Textline, referring to a smaller Indentation.
It may refer to the specific difference in Indentation, or to the act
of reducing the Leading whitespace on a Textline.</p></li>
<li><p>Whitespace</p>

<p>Horizontal space between various words and components of the Textline.
Classified into Initial, Leading, Interior, and Trailing Whitespace.</p></li>
<li><p>Whiteline (linespace)</p>

<p>Vertical whitespace. A line containing only whitespace characters (spaces,
tabs) and a terminal newline. Also: blank line (where no characters are 
present).</p></li>
<li><p>Whitespace Semantics Extension (WSE)</p>

<p>The name proposed for the set of changes and extensions discussed in
this document.</p></li>
</ul>

<h2>The Newline Transform -- Implementation Internals</h2>

<p>The three Legacy Haml <em>preserve</em> facilities, <code>filter:preserve</code>, 
<code>helper:find_and_preserve</code> (and it's client <code>~expr</code>), and the related 
(wrt newline transform) <code>option:preserve</code> work as two-part operators. </p>

<p>The operator performs its transform on HamlSource. The result is then 
subject to any further Haml processing, and that result becomes HtmlOutput. </p>

<p>That the first operation converts the newlines directly to an Html Entity 
is just an implementer's convenience. </p>

<p>It might better have been any other opaque string during the internal 
private processing (such as the code point '0xfffd' or '0xfffe', or the 
more ancient ASCII/EBCDIC-ish '0x1f') ... which if still present after 
Haml operations, would be converted by some Html-oriented operator to a 
contextually-relevant HtmlOutput character. </p>

<p>With the leading and trailing whitespaces having already been preserved 
through Haml processing, the appropriate Html character for HtmlOutput 
rarely is the <code>&amp;#x000A;</code> special character entity. </p>

<p>Where the targeted Html element is a preformatted-type, such as <code>&lt;pre&gt;</code>, 
the best-by-far character for all further Html-aware uses of the HtmlOutput 
is the author's own file-level platform-relevant newline. This is also true 
for most of the remaining cases. In vanishingly-few cases of 'preserving' 
is <code>&amp;#x000A;</code> the ideal character to emit in HtmlOutput--either for reasons 
of the Html source itself, or for Html semantics and rendering. </p>

<p>Apart from the implementation details of 'preserving' (which should be 
hidden), the choice for <code>&amp;#x000A;</code> encoding moves net-positive when the 
author is targeting a preserved fragment to a newline-sensitive process 
(such as portability, or binary processing), or when the author simply 
wants a fragment displayed in HtmlOutput as a single line.</p>

<h2>RSpec Suite</h2>

<p>Corresponding to this document is an RSpec test suite. </p>

<p>The plan is that the first, <em>OOImplementationNotes</em>, contain all the code,
in sequence (with the associated major head identified), as found in this 
document (WSE Implementation Notes).</p>

<p>The remaining files are by topic, somewhat overlapping with 
<em>00ImplementationNotes</em>, and with each other on common topics. These
files also contain documentation and tests for various features,
inconsistencies, nits, and bugs -- most of which are <strong>not</strong> discussed
in this document, and are <strong>not</strong> included in the <em>00</em> file.</p>

<ul>
<li>00ImplementationNotes_spec.rb</li>
<li>01helpers_spec.rb</li>
<li>02initialwspc_spec.rb</li>
<li>03nesting_spec.rb</li>
<li>04preserve_spec.rb</li>
<li>05preformatted_spec.rb</li>
<li>06mixedcontent_spec.rb</li>
<li>07hamlcomments_spec.rb</li>
<li>08htmlcomments_spec.rb</li>
<li>09multiline_spec.rb</li>
<li>10verticalwspc_spec.rb</li>
<li>11htmlescaping_spec.rb</li>
<li>12heredoc_spec.rb</li>
<li>13wspcremoval_spec.rb</li>
<li>14doctype_spec.rb</li>
</ul>
